{"version":3,"file":"index.js","mappings":"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ACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC,aAAa,uBAAuB;AACpC,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;AChLhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,qBAAqB,mBAAO,CAAC,gDAAc;AAC3C,mBAAmB,mBAAO,CAAC,oCAAe;AAC1C,yBAAyB,mBAAO,CAAC,4DAA0B;AAC3D,4BAA4B,mBAAO,CAAC,wEAAgC;AACpE,8BAA8B,mBAAO,CAAC,gFAAoC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB,GAAG;AACpB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gBAAgB,2CAA2C,IAAI;AACxG;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB,GAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;AC5DT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,qBAAqB,mBAAO,CAAC,gDAAc;AAC3C;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB,GAAG;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;AC1BP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAe;AACf,yBAAyB,mBAAO,CAAC,2DAAyB;AAC1D,4BAA4B,mBAAO,CAAC,uEAA+B;AACnE,8BAA8B,mBAAO,CAAC,+EAAmC;AACzE;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,gCAAgC,mBAAO,CAAC,oFAAuC;AAC/E,mBAAmB,mBAAO,CAAC,kCAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,GAAG;AAClB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,GAAG;AAClB,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,QAAQ;AACnH;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;ACzGd;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,eAAe,GAAG,sBAAsB,GAAG,2BAA2B,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,6BAA6B,GAAG,kBAAkB,GAAG,6BAA6B,GAAG,uBAAuB;AACjQ,0BAA0B,mBAAO,CAAC,qEAA8B;AAChE,mDAAkD,EAAE,qCAAqC,6CAA6C,EAAC;AACvI,gCAAgC,mBAAO,CAAC,iFAAoC;AAC5E,yDAAwD,EAAE,qCAAqC,yDAAyD,EAAC;AACzJ,qBAAqB,mBAAO,CAAC,2DAAyB;AACtD,8CAA6C,EAAE,qCAAqC,mCAAmC,EAAC;AACxH,gCAAgC,mBAAO,CAAC,iFAAoC;AAC5E,yDAAwD,EAAE,qCAAqC,yDAAyD,EAAC;AACzJ,yBAAyB,mBAAO,CAAC,mEAA6B;AAC9D,kDAAiD,EAAE,qCAAqC,2CAA2C,EAAC;AACpI,uBAAuB,mBAAO,CAAC,+DAA2B;AAC1D,gDAA+C,EAAE,qCAAqC,uCAAuC,EAAC;AAC9H,8BAA8B,mBAAO,CAAC,+EAAmC;AACzE,uDAAsD,EAAE,qCAAqC,qDAAqD,EAAC;AACnJ,yBAAyB,mBAAO,CAAC,2DAAyB;AAC1D,kDAAiD,EAAE,qCAAqC,2CAA2C,EAAC;AACpI,2CAA0C,EAAE,qCAAqC,oCAAoC,EAAC;AACtH,4BAA4B,mBAAO,CAAC,uEAA+B;AACnE,qDAAoD,EAAE,qCAAqC,iDAAiD,EAAC;AAC7I,gCAAgC,mBAAO,CAAC,2BAAS;AACjD,kBAAe;;;;;;;;;;;AC1BF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,eAAe;AACxC,mBAAmB,mBAAO,CAAC,kCAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,iCAAiC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,6BAA6B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,kCAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,6BAA6B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,+CAA+C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,yCAAyC;AACnE;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA,+BAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,kDAAkD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,8CAA8C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,+CAA+C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,2CAA2C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,sCAAsC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;AC5XT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,mBAAmB,mBAAO,CAAC,kCAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;UCxFzB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://smartcal/webpack/universalModuleDefinition","webpack://smartcal/./constant.ts","webpack://smartcal/./expression/BinaryOperation.ts","webpack://smartcal/./expression/ConditionalExpression.ts","webpack://smartcal/./expression/Expression.ts","webpack://smartcal/./expression/ExpressionConstructor.ts","webpack://smartcal/./expression/FieldReference.ts","webpack://smartcal/./expression/LiteralValue.ts","webpack://smartcal/./index.ts","webpack://smartcal/./interpreter/FormularInterpreter.ts","webpack://smartcal/./main.ts","webpack://smartcal/./parser/FormularParser.ts","webpack://smartcal/./tokenizer/FormularTokenizer.ts","webpack://smartcal/webpack/bootstrap","webpack://smartcal/webpack/before-startup","webpack://smartcal/webpack/startup","webpack://smartcal/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"smartcal\"] = factory();\n\telse\n\t\troot[\"smartcal\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Priority_4_Operator = exports.Priority_3_Operator = exports.Priority_2_Operator = exports.Priority_1_Operator = exports.AllOperators = exports.Operators = exports.ArithmeticOperator = exports.ComparisonOperator = exports.BackslashOperator = exports.QuestionMarkOperator = exports.ColonOperator = exports.ParenthesisCloseOperator = exports.ParenthesisOpenOperator = exports.AssignmentOperator = exports.NotEqualOperator = exports.EqualOperator = exports.LessThanOrEqualOperator = exports.GreaterThanOrEqualOperator = exports.LessThanOperator = exports.GreaterThanOperator = exports.LogicalOrOperator = exports.LogicalAndOperator = exports.ExponentialOperator = exports.MultiplicationOperator = exports.DivisionOperator = exports.SubtractionOperator = exports.AdditionOperator = exports.REGEX = void 0;\nexports.REGEX = {\n    formularOperatorG: /(<=|\\^|>=|==|\\|\\||&&|!=|[+/\\-*=()<>?:])/g,\n    formularOperator: /(<=|>=|\\^|==|\\|\\||&&|!=|[+/\\-*=()<>?!:])/,\n    formularFieldName: /f_[\\w]/, // that is regex that identify the formular fieldName\n};\n// Arithmetics operators\nexports.AdditionOperator = \"+\";\nexports.SubtractionOperator = \"-\";\nexports.DivisionOperator = \"/\";\nexports.MultiplicationOperator = \"*\";\nexports.ExponentialOperator = \"^\";\n// Logics operators\nexports.LogicalAndOperator = \"&&\";\nexports.LogicalOrOperator = \"||\";\n// Comparisons operators\nexports.GreaterThanOperator = \">\";\nexports.LessThanOperator = \"<\";\nexports.GreaterThanOrEqualOperator = \">=\";\nexports.LessThanOrEqualOperator = \"<=\";\nexports.EqualOperator = \"==\";\nexports.NotEqualOperator = \"!=\";\n// Others operators\nexports.AssignmentOperator = \"=\";\nexports.ParenthesisOpenOperator = \"(\";\nexports.ParenthesisCloseOperator = \")\";\nexports.ColonOperator = \":\";\nexports.QuestionMarkOperator = \"?\";\nexports.BackslashOperator = \"\\\\\";\nexports.ComparisonOperator = [\n    exports.GreaterThanOperator,\n    exports.LessThanOperator,\n    exports.LogicalOrOperator,\n    exports.LogicalAndOperator,\n    exports.GreaterThanOrEqualOperator,\n    exports.LessThanOrEqualOperator,\n    exports.EqualOperator,\n    exports.NotEqualOperator,\n];\nexports.ArithmeticOperator = [\n    exports.AdditionOperator,\n    exports.SubtractionOperator,\n    exports.DivisionOperator,\n    exports.MultiplicationOperator,\n    exports.ExponentialOperator,\n];\nexports.Operators = [\n    ...exports.ArithmeticOperator,\n    ...exports.ComparisonOperator,\n    exports.QuestionMarkOperator,\n];\nexports.AllOperators = [\n    ...exports.Operators,\n    exports.ColonOperator,\n    exports.ParenthesisCloseOperator,\n    exports.ParenthesisOpenOperator,\n];\nexports.Priority_1_Operator = [exports.AdditionOperator, exports.SubtractionOperator];\nexports.Priority_2_Operator = [exports.DivisionOperator, exports.MultiplicationOperator];\nexports.Priority_3_Operator = [exports.ExponentialOperator];\nexports.Priority_4_Operator = [\n    ...exports.ComparisonOperator,\n    exports.QuestionMarkOperator,\n];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BinaryOperation = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a binary operation on two expressions.\n *\n * @template T The input type of the expression.\n * @template R The output type of the expressions.\n * @param {Expression<T, R>} left The left expression.\n * @param {Expression<T, R>} right The right expression.\n * @param {(a: R, b: R) => number} operator The operator function that takes two values of type R and returns a number.\n */\nclass BinaryOperation extends Expression_1.Expression {\n    constructor(left, right, operator) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.operator = operator;\n    }\n    /**\n     * Executes the binary operation on the given object.\n     *\n     * @param {T} obj The object on which the operation will be executed.\n     * @returns {number} The result of the binary operation.\n     */\n    execute(obj) {\n        return this.operator(this.left.execute(obj), this.right.execute(obj));\n    }\n}\nexports.BinaryOperation = BinaryOperation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionalExpression = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a conditional expression that returns values based on a condition.\n *\n * @template T The input type of the expression.\n * @template R The output type of the conditional expression.\n * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.\n * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.\n * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.\n */\nclass ConditionalExpression extends Expression_1.Expression {\n    constructor(condition, isTrue, isFalse) {\n        super();\n        this.condition = condition;\n        this.isTrue = isTrue;\n        this.isFalse = isFalse;\n    }\n    /**\n     * Executes the conditional expression on the given object.\n     *\n     * @param {T} obj The object on which the expression will be evaluated.\n     * @returns {R} The value returned by the conditional expression, based on the evaluation of the condition.\n     */\n    execute(obj) {\n        return this.condition.execute(obj) != 0 ? this.isTrue.execute(obj) : this.isFalse.execute(obj);\n    }\n}\nexports.ConditionalExpression = ConditionalExpression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Expression = void 0;\n/**\n * Represents an abstract expression that defines an interface for evaluating expressions.\n * @template T The input type for the expression.\n * @template R The type of result produced by the expression.\n */\nclass Expression {\n}\nexports.Expression = Expression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExpressionConstructor = void 0;\nconst LiteralValue_1 = require(\"./LiteralValue\");\nconst FieldReference_1 = require(\"./FieldReference\");\nconst BinaryOperation_1 = require(\"./BinaryOperation\");\nconst ConditionalExpression_1 = require(\"./ConditionalExpression\");\nclass ExpressionConstructor {\n    /**\n     * Creates a literal value expression.\n     *\n     * @template T The input type of the expression.\n     * @template R The output type of the literal value.\n     * @param {R} value The value to be represented as a literal.\n     * @returns {Expression<T, R>} The literal value expression.\n     */\n    static literalValue(value) {\n        return new LiteralValue_1.LiteralValue(value);\n    }\n    /**\n     * Creates a field reference expression based on the provided field name.\n     *\n     * @template T The type of the input object.\n     * @template R The type of the output value from the field.\n     * @param {string} fieldName The name of the field to reference.\n     * @returns {Expression<T, R>} The field reference expression.\n     */\n    static fieldReference(fieldName) {\n        return new FieldReference_1.FieldReference(fieldName);\n    }\n    /**\n     * Creates an addition operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The addition expression.\n     */\n    static addition(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a + b);\n    }\n    /**\n     * Creates a subtraction operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The subtraction expression.\n     */\n    static subtraction(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a - b);\n    }\n    /**\n     * Creates a multiplication operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The multiplication expression.\n     */\n    static multiplication(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a * b);\n    }\n    /**\n     * Creates a division operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The division expression.\n     * @throws {Error} Throws an error if division by zero is attempted.\n     */\n    static division(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => {\n            if (b === 0)\n                throw new Error(\"Division by zero\");\n            return a / b;\n        });\n    }\n    /**\n     * Creates a conditional expression based on the specified condition.\n     *\n     * @template T The input type of the expression.\n     * @template R The output type of the conditional expression.\n     * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.\n     * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.\n     * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.\n     * @returns {Expression<T, R>} The conditional expression.\n     */\n    static condition(condition, isTrue, isFalse) {\n        return new ConditionalExpression_1.ConditionalExpression(condition, isTrue, isFalse);\n    }\n    /**\n     * Creates an equality expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The equality expression.\n     */\n    static equality(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a === b));\n    }\n    /**\n     * Creates a greater-than expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The greater-than expression.\n     */\n    static superior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a > b));\n    }\n    /**\n     * Creates a less-than expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The less-than expression.\n     */\n    static inferior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a < b));\n    }\n    /**\n     * Creates a not-equal expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The not-equal expression.\n     */\n    static different(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a != b));\n    }\n    /**\n     * Creates a logical OR expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The logical OR expression.\n     */\n    static or(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a || b));\n    }\n    /**\n     * Creates a logical AND expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The logical AND expression.\n     */\n    static and(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a && b));\n    }\n    /**\n   * Creates a power (exponentiation) expression between two expressions.\n   *\n   * @template T The input type of the expressions.\n   * @param {Expression<T, number>} base The base operand.\n   * @param {Expression<T, number>} exponent The exponent operand.\n   * @returns {Expression<T, number>} The result of raising `base` to the power of `right`.\n   */\n    static pow(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Math.pow(Number(a), Number(b)));\n    }\n}\nexports.ExpressionConstructor = ExpressionConstructor;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FieldReference = void 0;\nconst Expression_1 = require(\"./Expression\");\nconst constant_1 = require(\"./../constant\");\nconst FormularParser_1 = require(\"../parser/FormularParser\");\nconst FormularTokenizer_1 = require(\"../tokenizer/FormularTokenizer\");\nconst FormularInterpreter_1 = require(\"../interpreter/FormularInterpreter\");\n/**\n * Represents a reference to a field in a given object, allowing\n * for the execution of expressions and the interpretation of formulas.\n *\n * @template T - The type of the object containing the fields.\n * @template R - The type of the return value of the expression.\n * @param {string} fieldName - The name of the field to reference in the object.\n */\nclass FieldReference extends Expression_1.Expression {\n    constructor(fieldName) {\n        super();\n        this.fieldName = fieldName;\n    }\n    /**\n     * Executes the field reference on the given object.\n     *\n     * @param {T} obj - The object from which to extract the field value.\n     * @returns {R} The value of the referenced field.\n     * @throws {Error} If the field does not exist or is undefined in the object.\n     */\n    execute(obj) {\n        if (obj != null && obj != undefined) {\n            if (obj[this.fieldName] != undefined) {\n                if (this.isFormularRef())\n                    return this.executeFormularRef(obj);\n                return obj[this.fieldName];\n            }\n        }\n        throw new Error(`The fieldName ${this.fieldName} does not exist or is undefined on object ${obj}`);\n    }\n    /**\n     * Checks if the field name corresponds to a formula reference.\n     *\n     * @returns {boolean} True if the field is a formula reference, otherwise false.\n     */\n    isFormularRef() {\n        return constant_1.REGEX.formularFieldName.test(this.fieldName);\n    }\n    /**\n     * Executes the formula reference and returns the result of the interpretation.\n     *\n     * @param {T} obj - The object from which to extract the formula.\n     * @returns {R} The result of executing the formula.\n     */\n    executeFormularRef(obj) {\n        const fTokenizer = new FormularTokenizer_1.FormularTokenizer();\n        const fParser = new FormularParser_1.FormularParser();\n        const fInterpreter = new FormularInterpreter_1.FormularInterpreter();\n        const astTree = fParser.execute(fTokenizer.execute(obj[this.fieldName]));\n        return fInterpreter.execute(astTree, obj);\n    }\n}\nexports.FieldReference = FieldReference;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiteralValue = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a literal value expression.\n *\n * @template T The input type of the expression.\n * @template R The output type of the expression, defaulting to number.\n * @param {R} _value The literal value to be returned when executed.\n */\nclass LiteralValue extends Expression_1.Expression {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    /**\n     * Executes the literal value expression and returns the value.\n     *\n     * @param {T} obj The object on which the expression is executed (not used in this case).\n     * @returns {R} The literal value.\n     */\n    execute(obj) {\n        return this._value;\n    }\n}\nexports.LiteralValue = LiteralValue;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SmartCal;\nconst FormularParser_1 = require(\"./parser/FormularParser\");\nconst FormularTokenizer_1 = require(\"./tokenizer/FormularTokenizer\");\nconst FormularInterpreter_1 = require(\"./interpreter/FormularInterpreter\");\nfunction SmartCal(expression, obj) {\n    const fTokenizer = new FormularTokenizer_1.FormularTokenizer();\n    const fParser = new FormularParser_1.FormularParser();\n    const fInterpreter = new FormularInterpreter_1.FormularInterpreter();\n    return fInterpreter.execute(fParser.execute(fTokenizer.execute(expression)), obj);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormularInterpreter = void 0;\nconst ExpressionConstructor_1 = require(\"./../expression/ExpressionConstructor\");\nconst constant_1 = require(\"../constant\");\n/**\n * The FormularInterpreter class is responsible for interpreting an abstract syntax tree (AST)\n * representing a mathematical or logical expression. It evaluates expressions based on provided\n * variable data and constructs appropriate expression objects for processing.\n */\nclass FormularInterpreter {\n    /**\n     * Executes the interpretation of the AST tree and returns the evaluated result.\n     * @param {Node} astTree The abstract syntax tree to be interpreted.\n     * @param {T} data The variable data to use for evaluation.\n     * @returns {number | string} The result of the expression evaluation.\n     */\n    execute(astTree, data) {\n        const result = this.interpret(astTree, data).execute(data);\n        return result;\n    }\n    /**\n     * Interprets the AST tree recursively and constructs expression objects based on the node types.\n     * @param {Node} astTree The abstract syntax tree to interpret.\n     * @param {T} data The variable data to use for evaluation.\n     * @returns {Expression<T, string | number>} The constructed expression object.\n     */\n    interpret(astTree, data) {\n        if (astTree.isNode()) {\n            const operator = astTree.operator;\n            const right = this.interpret(astTree.right, data);\n            const left = this.interpret(astTree.left, data);\n            switch (operator) {\n                case constant_1.AdditionOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.addition(left, right);\n                case constant_1.SubtractionOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.subtraction(left, right);\n                case constant_1.MultiplicationOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.multiplication(left, right);\n                case constant_1.DivisionOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.division(left, right);\n                case constant_1.ExponentialOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.pow(left, right);\n                default:\n                    throw new Error(`This operator ${operator} is not supported.`);\n            }\n        }\n        else if (astTree.isValue()) {\n            const value = astTree.value;\n            if (typeof value === \"number\") {\n                return ExpressionConstructor_1.ExpressionConstructor.literalValue(Number(astTree.value));\n            }\n            else {\n                const regex = /\"([\\w]+)\"/;\n                const stringValue = value.match(regex)[1];\n                return ExpressionConstructor_1.ExpressionConstructor.literalValue(stringValue);\n            }\n        }\n        else if (astTree.isField()) {\n            const fieldValue = data[String(astTree.fieldName)];\n            if (fieldValue === undefined)\n                throw new Error(`The variable ${astTree.fieldName} not defined.`);\n            if (typeof fieldValue === \"number\") {\n                return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n            }\n            else {\n                return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n            }\n        }\n        else if (astTree.isComparison()) {\n            const comparisonOperator = astTree.operator;\n            const left = this.interpret(astTree.left, data);\n            const right = this.interpret(astTree.right, data);\n            switch (comparisonOperator) {\n                case constant_1.GreaterThanOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.superior(left, right);\n                case constant_1.LessThanOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.inferior(left, right);\n                case constant_1.EqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.equality(left, right);\n                case constant_1.GreaterThanOrEqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.superior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                case constant_1.LessThanOrEqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.inferior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                case constant_1.LogicalOrOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.or(left, right);\n                case constant_1.LogicalAndOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.and(left, right);\n                case constant_1.NotEqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.different(left, right);\n                default:\n                    throw new Error(`This comparison ${comparisonOperator} method is not supported`);\n            }\n        }\n        else if (astTree.isConditional()) {\n            const condition = this.interpret(astTree.condition, data);\n            const isTrue = this.interpret(astTree.isTrue, data);\n            const isFalse = this.interpret(astTree.isFalse, data);\n            return ExpressionConstructor_1.ExpressionConstructor.condition(condition, isTrue, isFalse);\n        }\n        else {\n            throw new Error(`This Expression is not Correct. Please verify Your expression [Interpreter]:${astTree}`);\n        }\n    }\n}\nexports.FormularInterpreter = FormularInterpreter;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormularTokenizer = exports.AstNode = exports.FormularParser = exports.FormularInterpreter = exports.LiteralValue = exports.FieldReference = exports.ExpressionConstructor = exports.Expression = exports.ConditionalExpression = exports.BinaryOperation = void 0;\nconst BinaryOperation_1 = require(\"./expression/BinaryOperation\");\nObject.defineProperty(exports, \"BinaryOperation\", { enumerable: true, get: function () { return BinaryOperation_1.BinaryOperation; } });\nconst ConditionalExpression_1 = require(\"./expression/ConditionalExpression\");\nObject.defineProperty(exports, \"ConditionalExpression\", { enumerable: true, get: function () { return ConditionalExpression_1.ConditionalExpression; } });\nconst Expression_1 = require(\"./expression/Expression\");\nObject.defineProperty(exports, \"Expression\", { enumerable: true, get: function () { return Expression_1.Expression; } });\nconst ExpressionConstructor_1 = require(\"./expression/ExpressionConstructor\");\nObject.defineProperty(exports, \"ExpressionConstructor\", { enumerable: true, get: function () { return ExpressionConstructor_1.ExpressionConstructor; } });\nconst FieldReference_1 = require(\"./expression/FieldReference\");\nObject.defineProperty(exports, \"FieldReference\", { enumerable: true, get: function () { return FieldReference_1.FieldReference; } });\nconst LiteralValue_1 = require(\"./expression/LiteralValue\");\nObject.defineProperty(exports, \"LiteralValue\", { enumerable: true, get: function () { return LiteralValue_1.LiteralValue; } });\nconst FormularInterpreter_1 = require(\"./interpreter/FormularInterpreter\");\nObject.defineProperty(exports, \"FormularInterpreter\", { enumerable: true, get: function () { return FormularInterpreter_1.FormularInterpreter; } });\nconst FormularParser_1 = require(\"./parser/FormularParser\");\nObject.defineProperty(exports, \"FormularParser\", { enumerable: true, get: function () { return FormularParser_1.FormularParser; } });\nObject.defineProperty(exports, \"AstNode\", { enumerable: true, get: function () { return FormularParser_1.AstNode; } });\nconst FormularTokenizer_1 = require(\"./tokenizer/FormularTokenizer\");\nObject.defineProperty(exports, \"FormularTokenizer\", { enumerable: true, get: function () { return FormularTokenizer_1.FormularTokenizer; } });\nconst index_1 = __importDefault(require(\"./index\"));\nexports.default = index_1.default;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormularParser = exports.AstNode = void 0;\nconst constant_1 = require(\"../constant\");\nconst OperatorValue = [...constant_1.ArithmeticOperator, ...constant_1.ComparisonOperator];\n/**\n * Represents a node in the Abstract Syntax Tree (AST).\n */\nclass AstNode {\n    /**\n     * Determines if this node is conditional.\n     * @returns {boolean} True if the node is conditional; otherwise, false.\n     */\n    isConditional() {\n        return !!this.condition && !!this.isFalse && !!this.isTrue;\n    }\n    /**\n     * Determines if this node represents a value.\n     * @returns {boolean} True if the node is a value; otherwise, false.\n     */\n    isValue() {\n        return this.value != undefined;\n    }\n    /**\n     * Determines if this node is a comparison operator.\n     * @returns {boolean} True if the node is a comparison; otherwise, false.\n     */\n    isComparison() {\n        return !!this.isComparisonOperator();\n    }\n    /**\n     * Determines if this node is a field.\n     * @returns {boolean} True if the node is a field; otherwise, false.\n     */\n    isField() {\n        return !!this.fieldName;\n    }\n    /**\n     * Determines if this node is a generic node.\n     * @returns {boolean} True if the node is a node; otherwise, false.\n     */\n    isNode() {\n        return (!this.isValue() &&\n            !this.isField() &&\n            !this.isComparison() &&\n            !this.isConditional());\n    }\n    /**\n     * Checks if the operator is a comparison operator.\n     * @returns {boolean} True if the operator is a comparison operator; otherwise, false.\n     */\n    isComparisonOperator() {\n        if (constant_1.ComparisonOperator.includes(this.operator))\n            return true;\n        return false;\n    }\n}\nexports.AstNode = AstNode;\n/**\n * Parses formulas and generates an Abstract Syntax Tree (AST).\n */\nclass FormularParser {\n    /**\n     * Checks if the provided tokens represent a valid formula.\n     * @param tokens - An array of tokens representing the formula.\n     * @returns {boolean} True if the tokens form a valid formula; otherwise, false.\n     */\n    isFormular(tokens) {\n        let notOperatorLastIndex = 1;\n        let operatorLastIndex = 1;\n        const operatorRegex = constant_1.REGEX.formularOperator;\n        for (let index = 0; index < tokens.length; index++) {\n            const token = tokens[index];\n            const isOperator = operatorRegex.test(String(token));\n            const lastIndex = index - 1;\n            if (isOperator) {\n                operatorLastIndex = index;\n            }\n            else {\n                if (notOperatorLastIndex == lastIndex &&\n                    operatorLastIndex != lastIndex) {\n                    return false;\n                }\n                notOperatorLastIndex = index;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks the syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     */\n    checkSyntax(tokens) {\n        this.checkParenthesisSyntax(tokens);\n        this.checkOperatorSyntax(tokens);\n        this.checkTernaryConditionSyntax(tokens);\n    }\n    /**\n     * Checks the parenthesis syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is a parenthesis mismatch.\n     */\n    checkParenthesisSyntax(tokens) {\n        const stack = [];\n        tokens.forEach((token) => {\n            if (token === constant_1.ParenthesisOpenOperator)\n                stack.push(constant_1.ParenthesisOpenOperator);\n            if (token === constant_1.ParenthesisCloseOperator) {\n                if (stack.length === 0) {\n                    throw new Error(\"Parenthesis mismatch\");\n                }\n                stack.pop();\n            }\n        });\n        if (stack.length !== 0) {\n            throw new Error(\"Incorrect parenthesis disposition.\");\n        }\n    }\n    /**\n     * Checks the operator syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is an operator syntax error.\n     */\n    checkOperatorSyntax(tokens) {\n        const regex = /[+-\\/*]{2,}/;\n        const expression = tokens.join(\"\");\n        if (regex.test(expression)) {\n            throw new Error(\"Incorrect Operator error\");\n        }\n        const validOperationCheckerRegex = />=|<=|==|!=|&&|\\|\\||[+-\\/*<>\\^][\\w\\(]/;\n        if (!validOperationCheckerRegex.test(expression)) {\n            throw new Error(\"Incorrect Operator position for Operand\");\n        }\n    }\n    /**\n     * Checks the ternary condition syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is a ternary syntax error.\n     */\n    checkTernaryConditionSyntax(tokens) {\n        let ternaryQuestionMarkCount = 0;\n        let ternaryColonCount = 0;\n        tokens.forEach((token) => {\n            if (token === constant_1.QuestionMarkOperator)\n                ternaryQuestionMarkCount++;\n            if (token === constant_1.ColonOperator)\n                ternaryColonCount++;\n        });\n        if (ternaryQuestionMarkCount !== ternaryColonCount) {\n            throw new Error(\"Incorrect Ternary syntax: unmatched ? and :\");\n        }\n        const ternaryRegex = /[?:]/;\n        let expectingCondition = true;\n        tokens.forEach((token) => {\n            if (ternaryRegex.test(String(token))) {\n                if (expectingCondition && token === constant_1.ColonOperator) {\n                    throw new Error(\"Ternary syntax error: found ':' before '?'\");\n                }\n                expectingCondition = !expectingCondition;\n            }\n        });\n    }\n    /**\n     * Executes the parsing of the provided tokens and generates an AST.\n     * @param tokens - An array of tokens to parse.\n     * @returns {Node} The root node of the generated AST.\n     * @throws {Error} Throws an error if the tokens are not a valid formula.\n     */\n    execute(tokens) {\n        if (this.isFormular(tokens)) {\n            this.checkSyntax(tokens);\n            return this.parser(tokens);\n        }\n        else {\n            throw new Error(\"[Error]: Not formular\");\n        }\n    }\n    /**\n     * Parses the provided tokens and generates an AST.\n     * @param tokens - An array of tokens to parse.\n     * @returns {AstNode} The root node of the generated AST.\n     */\n    parser(tokens) {\n        const postFixExpression = this.infixToPostFix(tokens);\n        console.log(\"PostFix\", postFixExpression);\n        const result = this.generateAST(postFixExpression);\n        return result;\n    }\n    /**\n     * Generates an Abstract Syntax Tree (AST) from the given tokens.\n     * @param tokens - An array of tokens to generate the AST from.\n     * @returns {AstNode} The root node of the generated AST.\n     */\n    generateAST(tokens) {\n        const stack = [];\n        let counter = 0;\n        return this._generateAST(tokens, counter, stack);\n    }\n    /**\n     * Recursively generates the AST based on the provided tokens and the current index.\n     * @param tokens - An array of tokens to generate the AST from.\n     * @param index - The current index in the tokens array.\n     * @param stack - The stack of nodes being built for the AST.\n     * @returns {AstNode} The root node of the generated AST.\n     */\n    _generateAST(tokens, index, stack = []) {\n        const token = tokens[index];\n        if (token == undefined)\n            return stack[0];\n        if (this.isOperatorFirstAndParenthesis(token)) {\n            const node = new AstNode();\n            node.operator = token;\n            if (this.isArithmeticOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isComparisonOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isTernaryOperator(token)) {\n                node.isFalse = stack.pop();\n                node.isTrue = stack.pop();\n                node.condition = stack.pop();\n            }\n            stack.push(node);\n        }\n        else {\n            const node = new AstNode();\n            if (this.isValue(token)) {\n                node.value = token;\n            }\n            else {\n                node.fieldName = token;\n            }\n            stack.push(node);\n        }\n        return this._generateAST(tokens, index + 1, stack);\n    }\n    /**\n     * Converts infix tokens to postfix notation.\n     * @param tokens - An array of tokens in infix notation.\n     * @returns {(string | number)[]} An array of tokens in postfix notation.\n     */\n    infixToPostFix(tokens) {\n        const output = [];\n        const operators = [];\n        tokens.forEach((token) => {\n            if (!this.isOperatorFirstAndParenthesis(token)) {\n                output.push(token);\n            }\n            else {\n                const operatorAndParenthesis = String(token);\n                const priority = this.priority(operatorAndParenthesis);\n                if (operatorAndParenthesis === constant_1.ParenthesisOpenOperator) {\n                    operators.push(operatorAndParenthesis);\n                }\n                else if (operatorAndParenthesis === constant_1.ParenthesisCloseOperator) {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== constant_1.ParenthesisOpenOperator) {\n                        const operator = operators.pop();\n                        if (!(operator.trim() === constant_1.ParenthesisOpenOperator)) {\n                            output.push(operator);\n                        }\n                    }\n                    operators.pop();\n                }\n                else if (operatorAndParenthesis === constant_1.ColonOperator) {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== constant_1.QuestionMarkOperator) {\n                        output.push(operators.pop());\n                    }\n                }\n                else if (constant_1.Operators.includes(operatorAndParenthesis)) {\n                    while (operators.length > 0 &&\n                        this.priority(operators[operators.length - 1]) >= priority) {\n                        output.push(operators.pop());\n                    }\n                    operators.push(operatorAndParenthesis);\n                }\n                else {\n                    console.log(\"enter here\", operatorAndParenthesis, token);\n                }\n            }\n        });\n        while (operators.length > 0) {\n            output.push(operators.pop());\n        }\n        return output;\n    }\n    /**\n     * Determines the priority level of the given operator.\n     *\n     * Operators are assigned the following priority levels:\n     * 1 - Addition and Subtraction\n     * 2 - Multiplication and Division\n     * 3 - Comparison and Logical operators\n     *\n     * @param operator - The operator to evaluate.\n     * @returns {number} The priority level of the operator, where higher numbers indicate higher priority.\n     */\n    priority(operator) {\n        if (constant_1.Priority_1_Operator.includes(operator))\n            return 1;\n        if (constant_1.Priority_2_Operator.includes(operator))\n            return 2;\n        if (constant_1.Priority_3_Operator.includes(operator))\n            return 3;\n        if (constant_1.Priority_4_Operator.includes(operator))\n            return 4;\n        return 0;\n    }\n    /**\n     * Checks if the provided token is an operator or parenthesis.\n     *\n     * This method considers the following tokens as valid operators:\n     * Arithmetic operators: +, -, *, /\n     * Comparison operators: >, <, >=, <=, ==, !=\n     * Logical operators: ||, &&\n     * Ternary operator: ?\n     * Parentheses: (, )\n     *\n     * @param token - The token to evaluate.\n     * @returns  {boolean} -True if the token is an operator or parenthesis; otherwise, false.\n     */\n    isOperatorFirstAndParenthesis(token) {\n        if (constant_1.AllOperators.includes(String(token).trim()))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is an arithmetic operator.\n     *\n     * The valid arithmetic operators are: +, -, *, /,^\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} -True if the token is an arithmetic operator; otherwise, false.\n     */\n    isArithmeticOperator(token) {\n        if (constant_1.ArithmeticOperator.includes(token))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is a comparison operator.\n     *\n     * The valid comparison operators are: >, <, >=, <=, ==, !=, ||, &&\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} -  True if the token is a comparison operator; otherwise, false.\n     */\n    isComparisonOperator(token) {\n        if (constant_1.ComparisonOperator.includes(token))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is a ternary operator.\n     *\n     * The valid ternary operator is: ?\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} - True if the token is a ternary operator; otherwise, false.\n     */\n    isTernaryOperator(token) {\n        return constant_1.QuestionMarkOperator === token;\n    }\n    /**\n     * Checks if the provided token is a valid value.\n     *\n     * A valid value can be a number or a string matching the regex pattern for quoted words.\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} - True if the token is a valid value; otherwise, false.\n     */\n    isValue(token) {\n        const valueRegex = /\"[\\w]+\"/;\n        return typeof token === \"number\" || valueRegex.test(token) ? true : false;\n    }\n}\nexports.FormularParser = FormularParser;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormularTokenizer = void 0;\nconst constant_1 = require(\"../constant\");\n/**\n * The FormularTokenizer class is responsible for tokenizing and formatting\n * mathematical expressions for further evaluation. It handles the input\n * string by formatting it, filtering tokens, and preparing them for processing.\n */\nclass FormularTokenizer {\n    /**\n     * Formats the input string by replacing operators and trimming whitespace.\n     * @param {string} input The input string to be formatted.\n     * @returns {string} The formatted expression.\n     */\n    formatInput(input) {\n        return input\n            .replace(constant_1.REGEX.formularOperatorG, \" $1 \")\n            .replace(/\\s+/g, \" \")\n            .trim();\n    }\n    /**\n     * Filters the tokens to handle numbers and operators appropriately.\n     * This method processes the tokens to ensure that numbers and operators\n     * are in the correct format for evaluation.\n     * @param {string[]} tokens The array of tokens to be filtered.\n     * @returns {(string | number)[]} The filtered tokens as an array of strings and numbers.\n     */\n    filterTokens(tokens) {\n        const filteredTokens = [];\n        let expectedClosedParenthesis = false;\n        tokens.forEach((token) => {\n            console.log(token);\n            const regex = /^\\d+(\\.\\d+)?$/;\n            const negativeNumberRegex = /-\\d+/;\n            const lastFilteredToken = filteredTokens[filteredTokens.length - 1];\n            if (regex.test(token)) {\n                const firstPop = filteredTokens.pop();\n                const secondPop = filteredTokens.pop();\n                if (firstPop != undefined && secondPop != undefined) {\n                    if (constant_1.Priority_1_Operator.includes(firstPop) &&\n                        secondPop === constant_1.ParenthesisOpenOperator) {\n                        filteredTokens.push(Number(firstPop + token));\n                        expectedClosedParenthesis = true;\n                    }\n                    else {\n                        filteredTokens.push(secondPop, firstPop, Number(token));\n                    }\n                }\n                else {\n                    if (secondPop == undefined) {\n                        if (firstPop != undefined) {\n                            filteredTokens.push(firstPop, Number(token));\n                        }\n                        else {\n                            filteredTokens.push(Number(token));\n                        }\n                    }\n                    else {\n                        filteredTokens.push(Number(token));\n                    }\n                }\n            }\n            else if (negativeNumberRegex.test(lastFilteredToken) &&\n                token === constant_1.ParenthesisCloseOperator &&\n                expectedClosedParenthesis) {\n                expectedClosedParenthesis = false;\n            }\n            else {\n                filteredTokens.push(token);\n            }\n        });\n        return filteredTokens;\n    }\n    /**\n     * Executes the tokenization process for the given input string.\n     * This method formats the input, splits it into tokens,\n     * and filters the tokens to produce a final result.\n     * @param {string} input The input string to be tokenized.\n     * @returns {any[]} The array of filtered tokens resulting from the tokenization process.\n     */\n    execute(input) {\n        const formattedInput = this.formatInput(input);\n        const tokens = formattedInput.split(\" \");\n        const filteredTokens = this.filterTokens(tokens);\n        return filteredTokens;\n    }\n}\nexports.FormularTokenizer = FormularTokenizer;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./main.ts\");\n",""],"names":[],"sourceRoot":""}