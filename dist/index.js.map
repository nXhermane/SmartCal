{"version":3,"file":"index.js","mappings":"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","sources":["webpack://smartcal/webpack/universalModuleDefinition","webpack://smartcal/./api/Compile.ts","webpack://smartcal/./api/SmartCal.ts","webpack://smartcal/./api/index.ts","webpack://smartcal/./api/isValidExpression.ts","webpack://smartcal/./constant.ts","webpack://smartcal/./expression/BinaryOperation.ts","webpack://smartcal/./expression/ConditionalExpression.ts","webpack://smartcal/./expression/Expression.ts","webpack://smartcal/./expression/ExpressionConstructor.ts","webpack://smartcal/./expression/FieldReference.ts","webpack://smartcal/./expression/LiteralValue.ts","webpack://smartcal/./index.ts","webpack://smartcal/./interpreter/FormulaInterpreter.ts","webpack://smartcal/./parser/FormulaParser.ts","webpack://smartcal/./tokenizer/FormulaTokenizer.ts","webpack://smartcal/webpack/bootstrap","webpack://smartcal/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"smartcal\"] = factory();\n\telse\n\t\troot[\"smartcal\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompiledFormulaExpression = void 0;\nexports.compile = compile;\nconst FormulaInterpreter_1 = require(\"../interpreter/FormulaInterpreter\");\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\n/**\n * Implementation of the CompiledExpression interface for formula expressions.\n * @class\n * @implements {CompiledExpression}\n */\nclass CompiledFormulaExpression {\n    /**\n     * Creates a new instance of CompiledFormulaExpression.\n     * @param {string} expression - The formula expression to compile\n     */\n    constructor(expression) {\n        this.expression = expression;\n        this._ast = new FormulaParser_1.FormulaParser().execute(new FormulaTokenizer_1.FormulaTokenizer().execute(expression));\n    }\n    /**\n     * Evaluates the expression with the provided data.\n     * @template T\n     * @param {T} data - The data object to evaluate the expression against\n     * @returns {string | number} The result of the evaluation\n     */\n    evaluate(data) {\n        return new FormulaInterpreter_1.FormulaInterpreter().execute(this._ast, data);\n    }\n    /**\n     * Returns the string representation of the expression.\n     * @returns {string} The original expression string\n     */\n    toString() {\n        return this.expression;\n    }\n}\nexports.CompiledFormulaExpression = CompiledFormulaExpression;\n/**\n * Compiles a formula expression string into a CompiledExpression object.\n * @param {string} expression - The formula expression to compile\n * @returns {CompiledExpression} A compiled expression that can be evaluated\n * @example\n * const expr = compile(\"age+3\");\n * const result = expr.evaluate({age:18});\n */\nfunction compile(expression) {\n    return new CompiledFormulaExpression(expression);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SmartCal;\nconst FormulaInterpreter_1 = require(\"../interpreter/FormulaInterpreter\");\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\n/**\n * Evaluates a mathematical expression and returns the result.\n *\n * This function parses and interprets a mathematical formula represented as a string,\n * applying dynamic values from a given object to resolve variables or conditions within the expression.\n *\n * @template T - A generic type representing the structure of the input object. Keys are variable names, and values can be numbers, strings, or arrays.\n * @param {string} expression - The mathematical expression to be evaluated.\n *        Variables in the expression should correspond to keys in the `obj` parameter.\n * @param {T} obj - An object containing the values of the variables referenced in the expression.\n * @returns {number | string | any[]} - The result of the evaluated expression, which can be a number, a string, or an array depending on the expression's logic.\n */\nfunction SmartCal(expression, obj) {\n    const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n    const fParser = new FormulaParser_1.FormulaParser();\n    const fInterpreter = new FormulaInterpreter_1.FormulaInterpreter();\n    return fInterpreter.execute(fParser.execute(fTokenizer.execute(expression)), obj || {});\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./SmartCal\"), exports);\n__exportStar(require(\"./isValidExpression\"), exports);\n__exportStar(require(\"./Compile\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidExpression = isValidExpression;\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\n/**\n * Verify if the given expression is valid formula\n * @param expression expression to evaluate\n * @returns {boolean} true if the expression is valid\n */\nfunction isValidExpression(expression) {\n    try {\n        const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n        const fParser = new FormulaParser_1.FormulaParser();\n        const tokens = fTokenizer.execute(expression);\n        return fParser.isValidFormula(tokens);\n    }\n    catch (_a) {\n        return false;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Priority_4_Operator = exports.Priority_3_Operator = exports.Priority_2_Operator = exports.Priority_1_Operator = exports.AllOperators = exports.Operators = exports.ArithmeticOperator = exports.ComparisonOperator = exports.BackslashOperator = exports.QuestionMarkOperator = exports.ColonOperator = exports.ParenthesisCloseOperator = exports.ParenthesisOpenOperator = exports.AssignmentOperator = exports.NotEqualOperator = exports.EqualOperator = exports.LessThanOrEqualOperator = exports.GreaterThanOrEqualOperator = exports.LessThanOperator = exports.GreaterThanOperator = exports.LogicalOrOperator = exports.LogicalAndOperator = exports.ModuloOperator = exports.ExponentialOperator = exports.MultiplicationOperator = exports.DivisionOperator = exports.SubtractionOperator = exports.AdditionOperator = exports.ConditionResult = exports.REGEX = void 0;\nexports.REGEX = {\n    formulaOperatorG: /(<=|\\^|%|>=|==|\\|\\||&&|!=|[+/\\-*=()<>?:])/g,\n    formulaOperator: /(<=|>=|\\^|%|==|\\|\\||&&|!=|[+/\\-*=()<>?!:])/,\n    formulaFieldName: /f_[\\w]/, // that is regex that identify the formula fieldName\n};\nexports.ConditionResult = {\n    True: 1,\n    False: 0,\n};\n// Arithmetics operators\nexports.AdditionOperator = \"+\";\nexports.SubtractionOperator = \"-\";\nexports.DivisionOperator = \"/\";\nexports.MultiplicationOperator = \"*\";\nexports.ExponentialOperator = \"^\";\nexports.ModuloOperator = \"%\";\n// Logics operators\nexports.LogicalAndOperator = \"&&\";\nexports.LogicalOrOperator = \"||\";\n// Comparisons operators\nexports.GreaterThanOperator = \">\";\nexports.LessThanOperator = \"<\";\nexports.GreaterThanOrEqualOperator = \">=\";\nexports.LessThanOrEqualOperator = \"<=\";\nexports.EqualOperator = \"==\";\nexports.NotEqualOperator = \"!=\";\n// Others operators\nexports.AssignmentOperator = \"=\";\nexports.ParenthesisOpenOperator = \"(\";\nexports.ParenthesisCloseOperator = \")\";\nexports.ColonOperator = \":\";\nexports.QuestionMarkOperator = \"?\";\nexports.BackslashOperator = \"\\\\\";\nexports.ComparisonOperator = [\n    exports.GreaterThanOperator,\n    exports.LessThanOperator,\n    exports.LogicalOrOperator,\n    exports.LogicalAndOperator,\n    exports.GreaterThanOrEqualOperator,\n    exports.LessThanOrEqualOperator,\n    exports.EqualOperator,\n    exports.NotEqualOperator,\n];\nexports.ArithmeticOperator = [\n    exports.AdditionOperator,\n    exports.SubtractionOperator,\n    exports.DivisionOperator,\n    exports.MultiplicationOperator,\n    exports.ExponentialOperator,\n    exports.ModuloOperator,\n];\nexports.Operators = [\n    ...exports.ArithmeticOperator,\n    ...exports.ComparisonOperator,\n    exports.QuestionMarkOperator,\n];\nexports.AllOperators = [\n    ...exports.Operators,\n    exports.ColonOperator,\n    exports.ParenthesisCloseOperator,\n    exports.ParenthesisOpenOperator,\n];\nexports.Priority_1_Operator = [exports.AdditionOperator, exports.SubtractionOperator];\nexports.Priority_2_Operator = [\n    exports.DivisionOperator,\n    exports.MultiplicationOperator,\n    exports.ModuloOperator,\n];\nexports.Priority_3_Operator = [exports.ExponentialOperator];\nexports.Priority_4_Operator = [\n    ...exports.ComparisonOperator,\n    exports.QuestionMarkOperator,\n];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BinaryOperation = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a binary operation on two expressions.\n *\n * @template T The input type of the expression.\n * @template R The output type of the expressions.\n * @param {Expression<T, R>} left The left expression.\n * @param {Expression<T, R>} right The right expression.\n * @param {(a: R, b: R) => number} operator The operator function that takes two values of type R and returns a number.\n */\nclass BinaryOperation extends Expression_1.Expression {\n    constructor(left, right, operator) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.operator = operator;\n    }\n    /**\n     * Executes the binary operation on the given object.\n     *\n     * @param {T} obj The object on which the operation will be executed.\n     * @returns {number} The result of the binary operation.\n     */\n    execute(obj) {\n        return this.operator(this.left.execute(obj), this.right.execute(obj));\n    }\n}\nexports.BinaryOperation = BinaryOperation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionalExpression = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a conditional expression that returns values based on a condition.\n *\n * @template T The input type of the expression.\n * @template R The output type of the conditional expression.\n * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.\n * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.\n * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.\n */\nclass ConditionalExpression extends Expression_1.Expression {\n    constructor(condition, isTrue, isFalse) {\n        super();\n        this.condition = condition;\n        this.isTrue = isTrue;\n        this.isFalse = isFalse;\n    }\n    /**\n     * Executes the conditional expression on the given object.\n     *\n     * @param {T} obj The object on which the expression will be evaluated.\n     * @returns {R} The value returned by the conditional expression, based on the evaluation of the condition.\n     */\n    execute(obj) {\n        return this.condition.execute(obj) != 0 ? this.isTrue.execute(obj) : this.isFalse.execute(obj);\n    }\n}\nexports.ConditionalExpression = ConditionalExpression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Expression = void 0;\n/**\n * Represents an abstract expression that defines an interface for evaluating expressions.\n * @template T The input type for the expression.\n * @template R The type of result produced by the expression.\n */\nclass Expression {\n}\nexports.Expression = Expression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExpressionConstructor = void 0;\nconst LiteralValue_1 = require(\"./LiteralValue\");\nconst FieldReference_1 = require(\"./FieldReference\");\nconst BinaryOperation_1 = require(\"./BinaryOperation\");\nconst ConditionalExpression_1 = require(\"./ConditionalExpression\");\nclass ExpressionConstructor {\n    /**\n     * Creates a literal value expression.\n     *\n     * @template T The input type of the expression.\n     * @template R The output type of the literal value.\n     * @param {R} value The value to be represented as a literal.\n     * @returns {Expression<T, R>} The literal value expression.\n     */\n    static literalValue(value) {\n        return new LiteralValue_1.LiteralValue(value);\n    }\n    /**\n     * Creates a field reference expression based on the provided field name.\n     *\n     * @template T The type of the input object.\n     * @template R The type of the output value from the field.\n     * @param {string} fieldName The name of the field to reference.\n     * @returns {Expression<T, R>} The field reference expression.\n     */\n    static fieldReference(fieldName) {\n        return new FieldReference_1.FieldReference(fieldName);\n    }\n    /**\n     * Creates an addition operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The addition expression.\n     */\n    static addition(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a + b);\n    }\n    /**\n     * Creates a subtraction operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The subtraction expression.\n     */\n    static subtraction(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a - b);\n    }\n    /**\n     * Creates a multiplication operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The multiplication expression.\n     */\n    static multiplication(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a * b);\n    }\n    /**\n     * Creates a division operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The division expression.\n     * @throws {Error} Throws an error if division by zero is attempted.\n     */\n    static division(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => {\n            if (b === 0)\n                throw new Error(\"Division by zero\");\n            return a / b;\n        });\n    }\n    /**\n     * Creates a conditional expression based on the specified condition.\n     *\n     * @template T The input type of the expression.\n     * @template R The output type of the conditional expression.\n     * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.\n     * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.\n     * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.\n     * @returns {Expression<T, R>} The conditional expression.\n     */\n    static condition(condition, isTrue, isFalse) {\n        return new ConditionalExpression_1.ConditionalExpression(condition, isTrue, isFalse);\n    }\n    /**\n     * Creates an equality expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The equality expression.\n     */\n    static equality(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a === b));\n    }\n    /**\n     * Creates a greater-than expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The greater-than expression.\n     */\n    static superior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a > b));\n    }\n    /**\n     * Creates a less-than expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The less-than expression.\n     */\n    static inferior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a < b));\n    }\n    /**\n     * Creates a not-equal expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The not-equal expression.\n     */\n    static different(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a != b));\n    }\n    /**\n     * Creates a logical OR expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The logical OR expression.\n     */\n    static or(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a || b));\n    }\n    /**\n     * Creates a logical AND expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The logical AND expression.\n     */\n    static and(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a && b));\n    }\n    /**\n     * Creates a power (exponentiation) expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @param {Expression<T, number>} base The base operand.\n     * @param {Expression<T, number>} exponent The exponent operand.\n     * @returns {Expression<T, number>} The result of raising `base` to the power of `right`.\n     */\n    static pow(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Math.pow(Number(a), Number(b)));\n    }\n    /**\n     * Creates a modulo operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The modulo expression.\n     */\n    static modulo(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a % b);\n    }\n}\nexports.ExpressionConstructor = ExpressionConstructor;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FieldReference = void 0;\nconst Expression_1 = require(\"./Expression\");\nconst constant_1 = require(\"./../constant\");\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\nconst FormulaInterpreter_1 = require(\"../interpreter/FormulaInterpreter\");\n/**\n * Represents a reference to a field in a given object, allowing\n * for the execution of expressions and the interpretation of formulas.\n *\n * @template T - The type of the object containing the fields.\n * @template R - The type of the return value of the expression.\n * @param {string} fieldName - The name of the field to reference in the object.\n */\nclass FieldReference extends Expression_1.Expression {\n    constructor(fieldName) {\n        super();\n        this.fieldName = fieldName;\n    }\n    /**\n     * Executes the field reference on the given object.\n     *\n     * @param {T} obj - The object from which to extract the field value.\n     * @returns {R} The value of the referenced field.\n     * @throws {Error} If the field does not exist or is undefined in the object.\n     */\n    execute(obj) {\n        if (obj != null && obj != undefined) {\n            if (obj[this.fieldName] != undefined) {\n                if (this.isFormulaRef())\n                    return this.executeFormulaRef(obj);\n                return obj[this.fieldName];\n            }\n        }\n        throw new Error(`The fieldName ${this.fieldName} does not exist or is undefined on object ${obj}`);\n    }\n    /**\n     * Checks if the field name corresponds to a formula reference.\n     *\n     * @returns {boolean} True if the field is a formula reference, otherwise false.\n     */\n    isFormulaRef() {\n        return constant_1.REGEX.formulaFieldName.test(this.fieldName);\n    }\n    /**\n     * Executes the formula reference and returns the result of the interpretation.\n     *\n     * @param {T} obj - The object from which to extract the formula.\n     * @returns {R} The result of executing the formula.\n     */\n    executeFormulaRef(obj) {\n        const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n        const fParser = new FormulaParser_1.FormulaParser();\n        const fInterpreter = new FormulaInterpreter_1.FormulaInterpreter();\n        const astTree = fParser.execute(fTokenizer.execute(obj[this.fieldName]));\n        return fInterpreter.execute(astTree, obj);\n    }\n}\nexports.FieldReference = FieldReference;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiteralValue = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a literal value expression.\n *\n * @template T The input type of the expression.\n * @template R The output type of the expression, defaulting to number.\n * @param {R} _value The literal value to be returned when executed.\n */\nclass LiteralValue extends Expression_1.Expression {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    /**\n     * Executes the literal value expression and returns the value.\n     *\n     * @param {T} obj The object on which the expression is executed (not used in this case).\n     * @returns {R} The literal value.\n     */\n    execute(obj) {\n        return this._value;\n    }\n}\nexports.LiteralValue = LiteralValue;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionResult = exports.FormulaTokenizer = exports.AstNode = exports.FormulaParser = exports.FormulaInterpreter = exports.LiteralValue = exports.FieldReference = exports.ExpressionConstructor = exports.Expression = exports.ConditionalExpression = exports.BinaryOperation = void 0;\nconst BinaryOperation_1 = require(\"./expression/BinaryOperation\");\nObject.defineProperty(exports, \"BinaryOperation\", { enumerable: true, get: function () { return BinaryOperation_1.BinaryOperation; } });\nconst ConditionalExpression_1 = require(\"./expression/ConditionalExpression\");\nObject.defineProperty(exports, \"ConditionalExpression\", { enumerable: true, get: function () { return ConditionalExpression_1.ConditionalExpression; } });\nconst Expression_1 = require(\"./expression/Expression\");\nObject.defineProperty(exports, \"Expression\", { enumerable: true, get: function () { return Expression_1.Expression; } });\nconst ExpressionConstructor_1 = require(\"./expression/ExpressionConstructor\");\nObject.defineProperty(exports, \"ExpressionConstructor\", { enumerable: true, get: function () { return ExpressionConstructor_1.ExpressionConstructor; } });\nconst FieldReference_1 = require(\"./expression/FieldReference\");\nObject.defineProperty(exports, \"FieldReference\", { enumerable: true, get: function () { return FieldReference_1.FieldReference; } });\nconst LiteralValue_1 = require(\"./expression/LiteralValue\");\nObject.defineProperty(exports, \"LiteralValue\", { enumerable: true, get: function () { return LiteralValue_1.LiteralValue; } });\nconst FormulaInterpreter_1 = require(\"./interpreter/FormulaInterpreter\");\nObject.defineProperty(exports, \"FormulaInterpreter\", { enumerable: true, get: function () { return FormulaInterpreter_1.FormulaInterpreter; } });\nconst FormulaParser_1 = require(\"./parser/FormulaParser\");\nObject.defineProperty(exports, \"FormulaParser\", { enumerable: true, get: function () { return FormulaParser_1.FormulaParser; } });\nObject.defineProperty(exports, \"AstNode\", { enumerable: true, get: function () { return FormulaParser_1.AstNode; } });\nconst FormulaTokenizer_1 = require(\"./tokenizer/FormulaTokenizer\");\nObject.defineProperty(exports, \"FormulaTokenizer\", { enumerable: true, get: function () { return FormulaTokenizer_1.FormulaTokenizer; } });\nconst constant_1 = require(\"./constant\");\nObject.defineProperty(exports, \"ConditionResult\", { enumerable: true, get: function () { return constant_1.ConditionResult; } });\n__exportStar(require(\"./api\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaInterpreter = void 0;\nconst ExpressionConstructor_1 = require(\"./../expression/ExpressionConstructor\");\nconst constant_1 = require(\"../constant\");\n/**\n * The FormulaInterpreter class is responsible for interpreting an abstract syntax tree (AST)\n * representing a mathematical or logical expression. It evaluates expressions based on provided\n * variable data and constructs appropriate expression objects for processing.\n */\nclass FormulaInterpreter {\n    /**\n     * Executes the interpretation of the AST tree and returns the evaluated result.\n     * @param {Node} astTree The abstract syntax tree to be interpreted.\n     * @param {T} data The variable data to use for evaluation.\n     * @returns {number | string} The result of the expression evaluation.\n     */\n    execute(astTree, data) {\n        const result = this.interpret(astTree, data).execute(data);\n        return result;\n    }\n    /**\n     * Interprets the AST tree recursively and constructs expression objects based on the node types.\n     * @param {Node} astTree The abstract syntax tree to interpret.\n     * @param {T} data The variable data to use for evaluation.\n     * @returns {Expression<T, string | number>} The constructed expression object.\n     */\n    interpret(astTree, data) {\n        if (astTree.isNode()) {\n            const operator = astTree.operator;\n            const right = this.interpret(astTree.right, data);\n            const left = this.interpret(astTree.left, data);\n            switch (operator) {\n                case constant_1.AdditionOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.addition(left, right);\n                case constant_1.SubtractionOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.subtraction(left, right);\n                case constant_1.MultiplicationOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.multiplication(left, right);\n                case constant_1.DivisionOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.division(left, right);\n                case constant_1.ModuloOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.modulo(left, right);\n                case constant_1.ExponentialOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.pow(left, right);\n                default:\n                    throw new Error(`This operator ${operator} is not supported.`);\n            }\n        }\n        else if (astTree.isValue()) {\n            const value = astTree.value;\n            if (typeof value === \"number\") {\n                return ExpressionConstructor_1.ExpressionConstructor.literalValue(Number(astTree.value));\n            }\n            else {\n                const regex = /\"([\\w]+)\"/;\n                const stringValue = value.match(regex)[1];\n                return ExpressionConstructor_1.ExpressionConstructor.literalValue(stringValue);\n            }\n        }\n        else if (astTree.isField()) {\n            const fieldValue = data[String(astTree.fieldName)];\n            if (fieldValue === undefined)\n                throw new Error(`The variable ${astTree.fieldName} not defined.`);\n            if (typeof fieldValue === \"number\") {\n                return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n            }\n            else {\n                return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n            }\n        }\n        else if (astTree.isComparison()) {\n            const comparisonOperator = astTree.operator;\n            const left = this.interpret(astTree.left, data);\n            const right = this.interpret(astTree.right, data);\n            switch (comparisonOperator) {\n                case constant_1.GreaterThanOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.superior(left, right);\n                case constant_1.LessThanOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.inferior(left, right);\n                case constant_1.EqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.equality(left, right);\n                case constant_1.GreaterThanOrEqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.superior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                case constant_1.LessThanOrEqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.inferior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                case constant_1.LogicalOrOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.or(left, right);\n                case constant_1.LogicalAndOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.and(left, right);\n                case constant_1.NotEqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.different(left, right);\n                default:\n                    throw new Error(`This comparison ${comparisonOperator} method is not supported`);\n            }\n        }\n        else if (astTree.isConditional()) {\n            const condition = this.interpret(astTree.condition, data);\n            const isTrue = this.interpret(astTree.isTrue, data);\n            const isFalse = this.interpret(astTree.isFalse, data);\n            return ExpressionConstructor_1.ExpressionConstructor.condition(condition, isTrue, isFalse);\n        }\n        else {\n            throw new Error(`This Expression is not Correct. Please verify Your expression [Interpreter]:${astTree}`);\n        }\n    }\n}\nexports.FormulaInterpreter = FormulaInterpreter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaParser = exports.AstNode = void 0;\nconst constant_1 = require(\"../constant\");\nconst OperatorValue = [...constant_1.ArithmeticOperator, ...constant_1.ComparisonOperator];\n/**\n * Represents a node in the Abstract Syntax Tree (AST).\n */\nclass AstNode {\n    /**\n     * Determines if this node is conditional.\n     * @returns {boolean} True if the node is conditional; otherwise, false.\n     */\n    isConditional() {\n        return !!this.condition && !!this.isFalse && !!this.isTrue;\n    }\n    /**\n     * Determines if this node represents a value.\n     * @returns {boolean} True if the node is a value; otherwise, false.\n     */\n    isValue() {\n        return this.value != undefined;\n    }\n    /**\n     * Determines if this node is a comparison operator.\n     * @returns {boolean} True if the node is a comparison; otherwise, false.\n     */\n    isComparison() {\n        return !!this.isComparisonOperator();\n    }\n    /**\n     * Determines if this node is a field.\n     * @returns {boolean} True if the node is a field; otherwise, false.\n     */\n    isField() {\n        return !!this.fieldName;\n    }\n    /**\n     * Determines if this node is a generic node.\n     * @returns {boolean} True if the node is a node; otherwise, false.\n     */\n    isNode() {\n        return (!this.isValue() &&\n            !this.isField() &&\n            !this.isComparison() &&\n            !this.isConditional());\n    }\n    /**\n     * Checks if the operator is a comparison operator.\n     * @returns {boolean} True if the operator is a comparison operator; otherwise, false.\n     */\n    isComparisonOperator() {\n        if (constant_1.ComparisonOperator.includes(this.operator))\n            return true;\n        return false;\n    }\n}\nexports.AstNode = AstNode;\n/**\n * Parses formulas and generates an Abstract Syntax Tree (AST).\n */\nclass FormulaParser {\n    /**\n     * Checks if the provided tokens represent a valid formula.\n     * @param tokens - An array of tokens representing the formula.\n     * @returns {boolean} True if the tokens form a valid formula; otherwise, false.\n     */\n    isFormula(tokens) {\n        let notOperatorLastIndex = 1;\n        let operatorLastIndex = 1;\n        const operatorRegex = constant_1.REGEX.formulaOperator;\n        for (let index = 0; index < tokens.length; index++) {\n            const token = tokens[index];\n            const isOperator = operatorRegex.test(String(token));\n            const lastIndex = index - 1;\n            if (isOperator) {\n                operatorLastIndex = index;\n            }\n            else {\n                if (notOperatorLastIndex == lastIndex &&\n                    operatorLastIndex != lastIndex) {\n                    return false;\n                }\n                notOperatorLastIndex = index;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks the syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     */\n    checkSyntax(tokens) {\n        this.checkParenthesisSyntax(tokens);\n        this.checkOperatorSyntax(tokens);\n        this.checkTernaryConditionSyntax(tokens);\n    }\n    /**\n     * Checks the parenthesis syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is a parenthesis mismatch.\n     */\n    checkParenthesisSyntax(tokens) {\n        const stack = [];\n        tokens.forEach((token) => {\n            if (token === constant_1.ParenthesisOpenOperator)\n                stack.push(constant_1.ParenthesisOpenOperator);\n            if (token === constant_1.ParenthesisCloseOperator) {\n                if (stack.length === 0) {\n                    throw new Error(\"Parenthesis mismatch\");\n                }\n                stack.pop();\n            }\n        });\n        if (stack.length !== 0) {\n            throw new Error(\"Incorrect parenthesis disposition.\");\n        }\n    }\n    /**\n     * Checks the operator syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is an operator syntax error.\n     */\n    checkOperatorSyntax(tokens) {\n        const regex = /[+-\\/*]{2,}/;\n        const expression = tokens.join(\"\");\n        if (regex.test(expression)) {\n            throw new Error(\"Incorrect Operator error\");\n        }\n        // When tokens length is equal to one and the token is an string or number without operator , just return because is just an operand\n        if (tokens.length == 1 && /\\w/.test(expression))\n            return;\n        const validOperationCheckerRegex = />=|<=|==|!=|&&|\\|\\||[+-\\/*<>%\\^][\\w\\(]/;\n        if (!validOperationCheckerRegex.test(expression)) {\n            throw new Error(\"Incorrect Operator position for Operand\");\n        }\n    }\n    /**\n     * Checks the ternary condition syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is a ternary syntax error.\n     */\n    checkTernaryConditionSyntax(tokens) {\n        let ternaryQuestionMarkCount = 0;\n        let ternaryColonCount = 0;\n        tokens.forEach((token) => {\n            if (token === constant_1.QuestionMarkOperator)\n                ternaryQuestionMarkCount++;\n            if (token === constant_1.ColonOperator)\n                ternaryColonCount++;\n        });\n        if (ternaryQuestionMarkCount !== ternaryColonCount) {\n            throw new Error(\"Incorrect Ternary syntax: unmatched ? and :\");\n        }\n        const ternaryRegex = /[?:]/;\n        let expectingCondition = true;\n        tokens.forEach((token) => {\n            if (ternaryRegex.test(String(token))) {\n                if (expectingCondition && token === constant_1.ColonOperator) {\n                    throw new Error(\"Ternary syntax error: found ':' before '?'\");\n                }\n                expectingCondition = !expectingCondition;\n            }\n        });\n    }\n    /**\n     * Check if the provided tokens is valid formula\n     * @param tokens - An array of tokens to verify if is valid formula\n     * @returns {boolean} return true when is valid formula and false if not\n     */\n    isValidFormula(tokens) {\n        try {\n            if (!this.isFormula(tokens))\n                return false;\n            this.checkSyntax(tokens);\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Executes the parsing of the provided tokens and generates an AST.\n     * @param tokens - An array of tokens to parse.\n     * @returns {Node} The root node of the generated AST.\n     * @throws {Error} Throws an error if the tokens are not a valid formula.\n     */\n    execute(tokens) {\n        if (tokens.length != 0 && this.isFormula(tokens)) {\n            this.checkSyntax(tokens);\n            return this.parser(tokens);\n        }\n        else {\n            throw new Error(\"[Error]: Not formula\");\n        }\n    }\n    /**\n     * Parses the provided tokens and generates an AST.\n     * @param tokens - An array of tokens to parse.\n     * @returns {AstNode} The root node of the generated AST.\n     */\n    parser(tokens) {\n        const postFixExpression = this.infixToPostFix(tokens);\n        const result = this.generateAST(postFixExpression);\n        return result;\n    }\n    /**\n     * Generates an Abstract Syntax Tree (AST) from the given tokens.\n     * @param tokens - An array of tokens to generate the AST from.\n     * @returns {AstNode} The root node of the generated AST.\n     */\n    generateAST(tokens) {\n        const stack = [];\n        let counter = 0;\n        return this._generateAST(tokens, counter, stack);\n    }\n    /**\n     * Recursively generates the AST based on the provided tokens and the current index.\n     * @param tokens - An array of tokens to generate the AST from.\n     * @param index - The current index in the tokens array.\n     * @param stack - The stack of nodes being built for the AST.\n     * @returns {AstNode} The root node of the generated AST.\n     */\n    _generateAST(tokens, index, stack = []) {\n        const token = tokens[index];\n        if (token == undefined)\n            return stack[0];\n        if (this.isOperatorFirstAndParenthesis(token)) {\n            const node = new AstNode();\n            node.operator = token;\n            if (this.isArithmeticOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isComparisonOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isTernaryOperator(token)) {\n                node.isFalse = stack.pop();\n                node.isTrue = stack.pop();\n                node.condition = stack.pop();\n            }\n            stack.push(node);\n        }\n        else {\n            const node = new AstNode();\n            if (this.isValue(token)) {\n                node.value = token;\n            }\n            else {\n                node.fieldName = token;\n            }\n            stack.push(node);\n        }\n        return this._generateAST(tokens, index + 1, stack);\n    }\n    /**\n     * Converts infix tokens to postfix notation.\n     * @param tokens - An array of tokens in infix notation.\n     * @returns {(string | number)[]} An array of tokens in postfix notation.\n     */\n    infixToPostFix(tokens) {\n        const output = [];\n        const operators = [];\n        tokens.forEach((token) => {\n            if (!this.isOperatorFirstAndParenthesis(token)) {\n                output.push(token);\n            }\n            else {\n                const operatorAndParenthesis = String(token);\n                const priority = this.priority(operatorAndParenthesis);\n                if (operatorAndParenthesis === constant_1.ParenthesisOpenOperator) {\n                    operators.push(operatorAndParenthesis);\n                }\n                else if (operatorAndParenthesis === constant_1.ParenthesisCloseOperator) {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== constant_1.ParenthesisOpenOperator) {\n                        const operator = operators.pop();\n                        if (!(operator.trim() === constant_1.ParenthesisOpenOperator)) {\n                            output.push(operator);\n                        }\n                    }\n                    operators.pop();\n                }\n                else if (operatorAndParenthesis === constant_1.ColonOperator) {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== constant_1.QuestionMarkOperator) {\n                        output.push(operators.pop());\n                    }\n                }\n                else if (constant_1.Operators.includes(operatorAndParenthesis)) {\n                    while (operators.length > 0 &&\n                        this.priority(operators[operators.length - 1]) >= priority) {\n                        output.push(operators.pop());\n                    }\n                    operators.push(operatorAndParenthesis);\n                }\n                else {\n                }\n            }\n        });\n        while (operators.length > 0) {\n            output.push(operators.pop());\n        }\n        return output;\n    }\n    /**\n     * Determines the priority level of the given operator.\n     *\n     * Operators are assigned the following priority levels:\n     * 1 - Addition and Subtraction\n     * 2 - Multiplication and Division\n     * 3 - Comparison and Logical operators\n     *\n     * @param operator - The operator to evaluate.\n     * @returns {number} The priority level of the operator, where higher numbers indicate higher priority.\n     */\n    priority(operator) {\n        if (constant_1.Priority_1_Operator.includes(operator))\n            return 1;\n        if (constant_1.Priority_2_Operator.includes(operator))\n            return 2;\n        if (constant_1.Priority_3_Operator.includes(operator))\n            return 3;\n        if (constant_1.Priority_4_Operator.includes(operator))\n            return 4;\n        return 0;\n    }\n    /**\n     * Checks if the provided token is an operator or parenthesis.\n     *\n     * This method considers the following tokens as valid operators:\n     * Arithmetic operators: +, -, *, /,^,%\n     * Comparison operators: >, <, >=, <=, ==, !=\n     * Logical operators: ||, &&\n     * Ternary operator: ?\n     * Parentheses: (, )\n     *\n     * @param token - The token to evaluate.\n     * @returns  {boolean} -True if the token is an operator or parenthesis; otherwise, false.\n     */\n    isOperatorFirstAndParenthesis(token) {\n        if (constant_1.AllOperators.includes(String(token).trim()))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is an arithmetic operator.\n     *\n     * The valid arithmetic operators are: +, -, *, /,^,%\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} -True if the token is an arithmetic operator; otherwise, false.\n     */\n    isArithmeticOperator(token) {\n        if (constant_1.ArithmeticOperator.includes(token))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is a comparison operator.\n     *\n     * The valid comparison operators are: >, <, >=, <=, ==, !=, ||, &&\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} -  True if the token is a comparison operator; otherwise, false.\n     */\n    isComparisonOperator(token) {\n        if (constant_1.ComparisonOperator.includes(token))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is a ternary operator.\n     *\n     * The valid ternary operator is: ?\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} - True if the token is a ternary operator; otherwise, false.\n     */\n    isTernaryOperator(token) {\n        return constant_1.QuestionMarkOperator === token;\n    }\n    /**\n     * Checks if the provided token is a valid value.\n     *\n     * A valid value can be a number or a string matching the regex pattern for quoted words.\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} - True if the token is a valid value; otherwise, false.\n     */\n    isValue(token) {\n        const valueRegex = /\"[\\w]+\"/;\n        return typeof token === \"number\" || valueRegex.test(token) ? true : false;\n    }\n}\nexports.FormulaParser = FormulaParser;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaTokenizer = void 0;\nconst constant_1 = require(\"../constant\");\n/**\n * The FormulaTokenizer class is responsible for tokenizing and formatting\n * mathematical expressions for further evaluation. It handles the input\n * string by formatting it, filtering tokens, and preparing them for processing.\n */\nclass FormulaTokenizer {\n    /**\n     * Formats the input string by replacing operators and trimming whitespace.\n     * @param {string} input The input string to be formatted.\n     * @returns {string} The formatted expression.\n     */\n    formatInput(input) {\n        return input\n            .replace(constant_1.REGEX.formulaOperatorG, \" $1 \")\n            .replace(/\\s+/g, \" \")\n            .trim();\n    }\n    /**\n     * Filters the tokens to handle numbers and operators appropriately.\n     * This method processes the tokens to ensure that numbers and operators\n     * are in the correct format for evaluation.\n     * @param {string[]} tokens The array of tokens to be filtered.\n     * @returns {(string | number)[]} The filtered tokens as an array of strings and numbers.\n     */\n    filterTokens(tokens) {\n        const filteredTokens = [];\n        let expectedClosedParenthesis = false;\n        tokens.forEach((token) => {\n            const regex = /^\\d+(\\.\\d+)?$/;\n            const negativeNumberRegex = /-\\d+/;\n            const lastFilteredToken = filteredTokens[filteredTokens.length - 1];\n            if (regex.test(token)) {\n                const firstPop = filteredTokens.pop();\n                const secondPop = filteredTokens.pop();\n                if (firstPop != undefined && secondPop != undefined) {\n                    if (constant_1.Priority_1_Operator.includes(firstPop) &&\n                        secondPop === constant_1.ParenthesisOpenOperator) {\n                        filteredTokens.push(Number(firstPop + token));\n                        expectedClosedParenthesis = true;\n                    }\n                    else {\n                        filteredTokens.push(secondPop, firstPop, Number(token));\n                    }\n                }\n                else {\n                    if (secondPop == undefined) {\n                        if (firstPop != undefined) {\n                            filteredTokens.push(firstPop, Number(token));\n                        }\n                        else {\n                            filteredTokens.push(Number(token));\n                        }\n                    }\n                    else {\n                        filteredTokens.push(Number(token));\n                    }\n                }\n            }\n            else if (negativeNumberRegex.test(lastFilteredToken) &&\n                token === constant_1.ParenthesisCloseOperator &&\n                expectedClosedParenthesis) {\n                expectedClosedParenthesis = false;\n            }\n            else {\n                filteredTokens.push(token);\n            }\n        });\n        return filteredTokens;\n    }\n    /**\n     * Executes the tokenization process for the given input string.\n     * This method formats the input, splits it into tokens,\n     * and filters the tokens to produce a final result.\n     * @param {string} input The input string to be tokenized.\n     * @returns {any[]} The array of filtered tokens resulting from the tokenization process.\n     */\n    execute(input) {\n        const formattedInput = this.formatInput(input);\n        if (formattedInput.trim() === \"\")\n            return [];\n        const tokens = formattedInput.split(\" \");\n        const filteredTokens = this.filterTokens(tokens);\n        return filteredTokens;\n    }\n}\nexports.FormulaTokenizer = FormulaTokenizer;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(73);\n"],"names":["root","factory","exports","module","define","amd","this","Object","defineProperty","value","CompiledFormulaExpression","compile","expression","FormulaInterpreter_1","FormulaParser_1","FormulaTokenizer_1","constructor","_ast","FormulaParser","execute","FormulaTokenizer","evaluate","data","FormulaInterpreter","toString","obj","fTokenizer","fParser","__createBinding","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","__exportStar","p","prototype","hasOwnProperty","call","isValidExpression","tokens","isValidFormula","_a","Priority_4_Operator","Priority_3_Operator","Priority_2_Operator","Priority_1_Operator","AllOperators","Operators","ArithmeticOperator","ComparisonOperator","BackslashOperator","QuestionMarkOperator","ColonOperator","ParenthesisCloseOperator","ParenthesisOpenOperator","AssignmentOperator","NotEqualOperator","EqualOperator","LessThanOrEqualOperator","GreaterThanOrEqualOperator","LessThanOperator","GreaterThanOperator","LogicalOrOperator","LogicalAndOperator","ModuloOperator","ExponentialOperator","MultiplicationOperator","DivisionOperator","SubtractionOperator","AdditionOperator","ConditionResult","REGEX","formulaOperatorG","formulaOperator","formulaFieldName","True","False","BinaryOperation","Expression_1","Expression","left","right","operator","super","ConditionalExpression","condition","isTrue","isFalse","ExpressionConstructor","LiteralValue_1","FieldReference_1","BinaryOperation_1","ConditionalExpression_1","literalValue","LiteralValue","fieldReference","fieldName","FieldReference","addition","a","b","subtraction","multiplication","division","Error","equality","Number","superior","inferior","different","or","and","pow","Math","modulo","constant_1","isFormulaRef","executeFormulaRef","test","fInterpreter","astTree","_value","AstNode","ExpressionConstructor_1","interpret","isNode","isValue","regex","stringValue","match","isField","fieldValue","String","isComparison","isConditional","comparisonOperator","isComparisonOperator","includes","isFormula","notOperatorLastIndex","operatorLastIndex","operatorRegex","index","length","token","lastIndex","checkSyntax","checkParenthesisSyntax","checkOperatorSyntax","checkTernaryConditionSyntax","stack","forEach","push","pop","join","ternaryQuestionMarkCount","ternaryColonCount","ternaryRegex","expectingCondition","parser","postFixExpression","infixToPostFix","generateAST","_generateAST","isOperatorFirstAndParenthesis","node","isArithmeticOperator","isTernaryOperator","output","operators","operatorAndParenthesis","priority","trim","formatInput","input","replace","filterTokens","filteredTokens","expectedClosedParenthesis","lastFilteredToken","firstPop","secondPop","formattedInput","split","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}