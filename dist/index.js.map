{"version":3,"file":"index.js","mappings":"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","sources":["webpack://smartcal/webpack/universalModuleDefinition","webpack://smartcal/./constant.ts","webpack://smartcal/./expression/BinaryOperation.ts","webpack://smartcal/./expression/ConditionalExpression.ts","webpack://smartcal/./expression/Expression.ts","webpack://smartcal/./expression/ExpressionConstructor.ts","webpack://smartcal/./expression/FieldReference.ts","webpack://smartcal/./expression/LiteralValue.ts","webpack://smartcal/./index.ts","webpack://smartcal/./interpreter/FormulaInterpreter.ts","webpack://smartcal/./main.ts","webpack://smartcal/./parser/FormulaParser.ts","webpack://smartcal/./tokenizer/FormulaTokenizer.ts","webpack://smartcal/webpack/bootstrap","webpack://smartcal/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"smartcal\"] = factory();\n\telse\n\t\troot[\"smartcal\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Priority_4_Operator = exports.Priority_3_Operator = exports.Priority_2_Operator = exports.Priority_1_Operator = exports.AllOperators = exports.Operators = exports.ArithmeticOperator = exports.ComparisonOperator = exports.BackslashOperator = exports.QuestionMarkOperator = exports.ColonOperator = exports.ParenthesisCloseOperator = exports.ParenthesisOpenOperator = exports.AssignmentOperator = exports.NotEqualOperator = exports.EqualOperator = exports.LessThanOrEqualOperator = exports.GreaterThanOrEqualOperator = exports.LessThanOperator = exports.GreaterThanOperator = exports.LogicalOrOperator = exports.LogicalAndOperator = exports.ModuloOperator = exports.ExponentialOperator = exports.MultiplicationOperator = exports.DivisionOperator = exports.SubtractionOperator = exports.AdditionOperator = exports.ConditionResult = exports.REGEX = void 0;\nexports.REGEX = {\n    formulaOperatorG: /(<=|\\^|%|>=|==|\\|\\||&&|!=|[+/\\-*=()<>?:])/g,\n    formulaOperator: /(<=|>=|\\^|%|==|\\|\\||&&|!=|[+/\\-*=()<>?!:])/,\n    formulaFieldName: /f_[\\w]/, // that is regex that identify the formula fieldName\n};\nexports.ConditionResult = {\n    True: 1,\n    False: 0,\n};\n// Arithmetics operators\nexports.AdditionOperator = \"+\";\nexports.SubtractionOperator = \"-\";\nexports.DivisionOperator = \"/\";\nexports.MultiplicationOperator = \"*\";\nexports.ExponentialOperator = \"^\";\nexports.ModuloOperator = \"%\";\n// Logics operators\nexports.LogicalAndOperator = \"&&\";\nexports.LogicalOrOperator = \"||\";\n// Comparisons operators\nexports.GreaterThanOperator = \">\";\nexports.LessThanOperator = \"<\";\nexports.GreaterThanOrEqualOperator = \">=\";\nexports.LessThanOrEqualOperator = \"<=\";\nexports.EqualOperator = \"==\";\nexports.NotEqualOperator = \"!=\";\n// Others operators\nexports.AssignmentOperator = \"=\";\nexports.ParenthesisOpenOperator = \"(\";\nexports.ParenthesisCloseOperator = \")\";\nexports.ColonOperator = \":\";\nexports.QuestionMarkOperator = \"?\";\nexports.BackslashOperator = \"\\\\\";\nexports.ComparisonOperator = [\n    exports.GreaterThanOperator,\n    exports.LessThanOperator,\n    exports.LogicalOrOperator,\n    exports.LogicalAndOperator,\n    exports.GreaterThanOrEqualOperator,\n    exports.LessThanOrEqualOperator,\n    exports.EqualOperator,\n    exports.NotEqualOperator,\n];\nexports.ArithmeticOperator = [\n    exports.AdditionOperator,\n    exports.SubtractionOperator,\n    exports.DivisionOperator,\n    exports.MultiplicationOperator,\n    exports.ExponentialOperator,\n    exports.ModuloOperator,\n];\nexports.Operators = [\n    ...exports.ArithmeticOperator,\n    ...exports.ComparisonOperator,\n    exports.QuestionMarkOperator,\n];\nexports.AllOperators = [\n    ...exports.Operators,\n    exports.ColonOperator,\n    exports.ParenthesisCloseOperator,\n    exports.ParenthesisOpenOperator,\n];\nexports.Priority_1_Operator = [exports.AdditionOperator, exports.SubtractionOperator];\nexports.Priority_2_Operator = [\n    exports.DivisionOperator,\n    exports.MultiplicationOperator,\n    exports.ModuloOperator,\n];\nexports.Priority_3_Operator = [exports.ExponentialOperator];\nexports.Priority_4_Operator = [\n    ...exports.ComparisonOperator,\n    exports.QuestionMarkOperator,\n];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BinaryOperation = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a binary operation on two expressions.\n *\n * @template T The input type of the expression.\n * @template R The output type of the expressions.\n * @param {Expression<T, R>} left The left expression.\n * @param {Expression<T, R>} right The right expression.\n * @param {(a: R, b: R) => number} operator The operator function that takes two values of type R and returns a number.\n */\nclass BinaryOperation extends Expression_1.Expression {\n    constructor(left, right, operator) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.operator = operator;\n    }\n    /**\n     * Executes the binary operation on the given object.\n     *\n     * @param {T} obj The object on which the operation will be executed.\n     * @returns {number} The result of the binary operation.\n     */\n    execute(obj) {\n        return this.operator(this.left.execute(obj), this.right.execute(obj));\n    }\n}\nexports.BinaryOperation = BinaryOperation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionalExpression = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a conditional expression that returns values based on a condition.\n *\n * @template T The input type of the expression.\n * @template R The output type of the conditional expression.\n * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.\n * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.\n * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.\n */\nclass ConditionalExpression extends Expression_1.Expression {\n    constructor(condition, isTrue, isFalse) {\n        super();\n        this.condition = condition;\n        this.isTrue = isTrue;\n        this.isFalse = isFalse;\n    }\n    /**\n     * Executes the conditional expression on the given object.\n     *\n     * @param {T} obj The object on which the expression will be evaluated.\n     * @returns {R} The value returned by the conditional expression, based on the evaluation of the condition.\n     */\n    execute(obj) {\n        return this.condition.execute(obj) != 0 ? this.isTrue.execute(obj) : this.isFalse.execute(obj);\n    }\n}\nexports.ConditionalExpression = ConditionalExpression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Expression = void 0;\n/**\n * Represents an abstract expression that defines an interface for evaluating expressions.\n * @template T The input type for the expression.\n * @template R The type of result produced by the expression.\n */\nclass Expression {\n}\nexports.Expression = Expression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExpressionConstructor = void 0;\nconst LiteralValue_1 = require(\"./LiteralValue\");\nconst FieldReference_1 = require(\"./FieldReference\");\nconst BinaryOperation_1 = require(\"./BinaryOperation\");\nconst ConditionalExpression_1 = require(\"./ConditionalExpression\");\nclass ExpressionConstructor {\n    /**\n     * Creates a literal value expression.\n     *\n     * @template T The input type of the expression.\n     * @template R The output type of the literal value.\n     * @param {R} value The value to be represented as a literal.\n     * @returns {Expression<T, R>} The literal value expression.\n     */\n    static literalValue(value) {\n        return new LiteralValue_1.LiteralValue(value);\n    }\n    /**\n     * Creates a field reference expression based on the provided field name.\n     *\n     * @template T The type of the input object.\n     * @template R The type of the output value from the field.\n     * @param {string} fieldName The name of the field to reference.\n     * @returns {Expression<T, R>} The field reference expression.\n     */\n    static fieldReference(fieldName) {\n        return new FieldReference_1.FieldReference(fieldName);\n    }\n    /**\n     * Creates an addition operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The addition expression.\n     */\n    static addition(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a + b);\n    }\n    /**\n     * Creates a subtraction operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The subtraction expression.\n     */\n    static subtraction(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a - b);\n    }\n    /**\n     * Creates a multiplication operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The multiplication expression.\n     */\n    static multiplication(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a * b);\n    }\n    /**\n     * Creates a division operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The division expression.\n     * @throws {Error} Throws an error if division by zero is attempted.\n     */\n    static division(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => {\n            if (b === 0)\n                throw new Error(\"Division by zero\");\n            return a / b;\n        });\n    }\n    /**\n     * Creates a conditional expression based on the specified condition.\n     *\n     * @template T The input type of the expression.\n     * @template R The output type of the conditional expression.\n     * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.\n     * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.\n     * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.\n     * @returns {Expression<T, R>} The conditional expression.\n     */\n    static condition(condition, isTrue, isFalse) {\n        return new ConditionalExpression_1.ConditionalExpression(condition, isTrue, isFalse);\n    }\n    /**\n     * Creates an equality expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The equality expression.\n     */\n    static equality(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a === b));\n    }\n    /**\n     * Creates a greater-than expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The greater-than expression.\n     */\n    static superior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a > b));\n    }\n    /**\n     * Creates a less-than expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The less-than expression.\n     */\n    static inferior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a < b));\n    }\n    /**\n     * Creates a not-equal expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The not-equal expression.\n     */\n    static different(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a != b));\n    }\n    /**\n     * Creates a logical OR expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The logical OR expression.\n     */\n    static or(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a || b));\n    }\n    /**\n     * Creates a logical AND expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The logical AND expression.\n     */\n    static and(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a && b));\n    }\n    /**\n     * Creates a power (exponentiation) expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @param {Expression<T, number>} base The base operand.\n     * @param {Expression<T, number>} exponent The exponent operand.\n     * @returns {Expression<T, number>} The result of raising `base` to the power of `right`.\n     */\n    static pow(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Math.pow(Number(a), Number(b)));\n    }\n    /**\n     * Creates a modulo operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The modulo expression.\n     */\n    static modulo(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a % b);\n    }\n}\nexports.ExpressionConstructor = ExpressionConstructor;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FieldReference = void 0;\nconst Expression_1 = require(\"./Expression\");\nconst constant_1 = require(\"./../constant\");\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\nconst FormulaInterpreter_1 = require(\"../interpreter/FormulaInterpreter\");\n/**\n * Represents a reference to a field in a given object, allowing\n * for the execution of expressions and the interpretation of formulas.\n *\n * @template T - The type of the object containing the fields.\n * @template R - The type of the return value of the expression.\n * @param {string} fieldName - The name of the field to reference in the object.\n */\nclass FieldReference extends Expression_1.Expression {\n    constructor(fieldName) {\n        super();\n        this.fieldName = fieldName;\n    }\n    /**\n     * Executes the field reference on the given object.\n     *\n     * @param {T} obj - The object from which to extract the field value.\n     * @returns {R} The value of the referenced field.\n     * @throws {Error} If the field does not exist or is undefined in the object.\n     */\n    execute(obj) {\n        if (obj != null && obj != undefined) {\n            if (obj[this.fieldName] != undefined) {\n                if (this.isFormulaRef())\n                    return this.executeFormulaRef(obj);\n                return obj[this.fieldName];\n            }\n        }\n        throw new Error(`The fieldName ${this.fieldName} does not exist or is undefined on object ${obj}`);\n    }\n    /**\n     * Checks if the field name corresponds to a formula reference.\n     *\n     * @returns {boolean} True if the field is a formula reference, otherwise false.\n     */\n    isFormulaRef() {\n        return constant_1.REGEX.formulaFieldName.test(this.fieldName);\n    }\n    /**\n     * Executes the formula reference and returns the result of the interpretation.\n     *\n     * @param {T} obj - The object from which to extract the formula.\n     * @returns {R} The result of executing the formula.\n     */\n    executeFormulaRef(obj) {\n        const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n        const fParser = new FormulaParser_1.FormulaParser();\n        const fInterpreter = new FormulaInterpreter_1.FormulaInterpreter();\n        const astTree = fParser.execute(fTokenizer.execute(obj[this.fieldName]));\n        return fInterpreter.execute(astTree, obj);\n    }\n}\nexports.FieldReference = FieldReference;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiteralValue = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a literal value expression.\n *\n * @template T The input type of the expression.\n * @template R The output type of the expression, defaulting to number.\n * @param {R} _value The literal value to be returned when executed.\n */\nclass LiteralValue extends Expression_1.Expression {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    /**\n     * Executes the literal value expression and returns the value.\n     *\n     * @param {T} obj The object on which the expression is executed (not used in this case).\n     * @returns {R} The literal value.\n     */\n    execute(obj) {\n        return this._value;\n    }\n}\nexports.LiteralValue = LiteralValue;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionResult = exports.isValidExpression = exports.FormulaTokenizer = exports.AstNode = exports.FormulaParser = exports.FormulaInterpreter = exports.LiteralValue = exports.FieldReference = exports.ExpressionConstructor = exports.Expression = exports.ConditionalExpression = exports.BinaryOperation = void 0;\nconst BinaryOperation_1 = require(\"./expression/BinaryOperation\");\nObject.defineProperty(exports, \"BinaryOperation\", { enumerable: true, get: function () { return BinaryOperation_1.BinaryOperation; } });\nconst ConditionalExpression_1 = require(\"./expression/ConditionalExpression\");\nObject.defineProperty(exports, \"ConditionalExpression\", { enumerable: true, get: function () { return ConditionalExpression_1.ConditionalExpression; } });\nconst Expression_1 = require(\"./expression/Expression\");\nObject.defineProperty(exports, \"Expression\", { enumerable: true, get: function () { return Expression_1.Expression; } });\nconst ExpressionConstructor_1 = require(\"./expression/ExpressionConstructor\");\nObject.defineProperty(exports, \"ExpressionConstructor\", { enumerable: true, get: function () { return ExpressionConstructor_1.ExpressionConstructor; } });\nconst FieldReference_1 = require(\"./expression/FieldReference\");\nObject.defineProperty(exports, \"FieldReference\", { enumerable: true, get: function () { return FieldReference_1.FieldReference; } });\nconst LiteralValue_1 = require(\"./expression/LiteralValue\");\nObject.defineProperty(exports, \"LiteralValue\", { enumerable: true, get: function () { return LiteralValue_1.LiteralValue; } });\nconst FormulaInterpreter_1 = require(\"./interpreter/FormulaInterpreter\");\nObject.defineProperty(exports, \"FormulaInterpreter\", { enumerable: true, get: function () { return FormulaInterpreter_1.FormulaInterpreter; } });\nconst FormulaParser_1 = require(\"./parser/FormulaParser\");\nObject.defineProperty(exports, \"FormulaParser\", { enumerable: true, get: function () { return FormulaParser_1.FormulaParser; } });\nObject.defineProperty(exports, \"AstNode\", { enumerable: true, get: function () { return FormulaParser_1.AstNode; } });\nconst FormulaTokenizer_1 = require(\"./tokenizer/FormulaTokenizer\");\nObject.defineProperty(exports, \"FormulaTokenizer\", { enumerable: true, get: function () { return FormulaTokenizer_1.FormulaTokenizer; } });\nconst main_1 = __importStar(require(\"./main\"));\nObject.defineProperty(exports, \"isValidExpression\", { enumerable: true, get: function () { return main_1.isValidExpression; } });\nconst constant_1 = require(\"./constant\");\nObject.defineProperty(exports, \"ConditionResult\", { enumerable: true, get: function () { return constant_1.ConditionResult; } });\nexports.default = main_1.default;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaInterpreter = void 0;\nconst ExpressionConstructor_1 = require(\"./../expression/ExpressionConstructor\");\nconst constant_1 = require(\"../constant\");\n/**\n * The FormulaInterpreter class is responsible for interpreting an abstract syntax tree (AST)\n * representing a mathematical or logical expression. It evaluates expressions based on provided\n * variable data and constructs appropriate expression objects for processing.\n */\nclass FormulaInterpreter {\n    /**\n     * Executes the interpretation of the AST tree and returns the evaluated result.\n     * @param {Node} astTree The abstract syntax tree to be interpreted.\n     * @param {T} data The variable data to use for evaluation.\n     * @returns {number | string} The result of the expression evaluation.\n     */\n    execute(astTree, data) {\n        const result = this.interpret(astTree, data).execute(data);\n        return result;\n    }\n    /**\n     * Interprets the AST tree recursively and constructs expression objects based on the node types.\n     * @param {Node} astTree The abstract syntax tree to interpret.\n     * @param {T} data The variable data to use for evaluation.\n     * @returns {Expression<T, string | number>} The constructed expression object.\n     */\n    interpret(astTree, data) {\n        if (astTree.isNode()) {\n            const operator = astTree.operator;\n            const right = this.interpret(astTree.right, data);\n            const left = this.interpret(astTree.left, data);\n            switch (operator) {\n                case constant_1.AdditionOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.addition(left, right);\n                case constant_1.SubtractionOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.subtraction(left, right);\n                case constant_1.MultiplicationOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.multiplication(left, right);\n                case constant_1.DivisionOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.division(left, right);\n                case constant_1.ModuloOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.modulo(left, right);\n                case constant_1.ExponentialOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.pow(left, right);\n                default:\n                    throw new Error(`This operator ${operator} is not supported.`);\n            }\n        }\n        else if (astTree.isValue()) {\n            const value = astTree.value;\n            if (typeof value === \"number\") {\n                return ExpressionConstructor_1.ExpressionConstructor.literalValue(Number(astTree.value));\n            }\n            else {\n                const regex = /\"([\\w]+)\"/;\n                const stringValue = value.match(regex)[1];\n                return ExpressionConstructor_1.ExpressionConstructor.literalValue(stringValue);\n            }\n        }\n        else if (astTree.isField()) {\n            const fieldValue = data[String(astTree.fieldName)];\n            if (fieldValue === undefined)\n                throw new Error(`The variable ${astTree.fieldName} not defined.`);\n            if (typeof fieldValue === \"number\") {\n                return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n            }\n            else {\n                return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n            }\n        }\n        else if (astTree.isComparison()) {\n            const comparisonOperator = astTree.operator;\n            const left = this.interpret(astTree.left, data);\n            const right = this.interpret(astTree.right, data);\n            switch (comparisonOperator) {\n                case constant_1.GreaterThanOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.superior(left, right);\n                case constant_1.LessThanOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.inferior(left, right);\n                case constant_1.EqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.equality(left, right);\n                case constant_1.GreaterThanOrEqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.superior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                case constant_1.LessThanOrEqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.inferior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                case constant_1.LogicalOrOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.or(left, right);\n                case constant_1.LogicalAndOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.and(left, right);\n                case constant_1.NotEqualOperator:\n                    return ExpressionConstructor_1.ExpressionConstructor.different(left, right);\n                default:\n                    throw new Error(`This comparison ${comparisonOperator} method is not supported`);\n            }\n        }\n        else if (astTree.isConditional()) {\n            const condition = this.interpret(astTree.condition, data);\n            const isTrue = this.interpret(astTree.isTrue, data);\n            const isFalse = this.interpret(astTree.isFalse, data);\n            return ExpressionConstructor_1.ExpressionConstructor.condition(condition, isTrue, isFalse);\n        }\n        else {\n            throw new Error(`This Expression is not Correct. Please verify Your expression [Interpreter]:${astTree}`);\n        }\n    }\n}\nexports.FormulaInterpreter = FormulaInterpreter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SmartCal;\nexports.isValidExpression = isValidExpression;\nconst FormulaParser_1 = require(\"./parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"./tokenizer/FormulaTokenizer\");\nconst FormulaInterpreter_1 = require(\"./interpreter/FormulaInterpreter\");\n/**\n * Evaluates a mathematical expression and returns the result.\n *\n * This function parses and interprets a mathematical formula represented as a string,\n * applying dynamic values from a given object to resolve variables or conditions within the expression.\n *\n * @template T - A generic type representing the structure of the input object. Keys are variable names, and values can be numbers, strings, or arrays.\n * @param {string} expression - The mathematical expression to be evaluated.\n *        Variables in the expression should correspond to keys in the `obj` parameter.\n * @param {T} obj - An object containing the values of the variables referenced in the expression.\n * @returns {number | string | any[]} - The result of the evaluated expression, which can be a number, a string, or an array depending on the expression's logic.\n */\nfunction SmartCal(expression, obj) {\n    const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n    const fParser = new FormulaParser_1.FormulaParser();\n    const fInterpreter = new FormulaInterpreter_1.FormulaInterpreter();\n    return fInterpreter.execute(fParser.execute(fTokenizer.execute(expression)), obj || {});\n}\n/**\n * Verify if the given expression is valid formula\n * @param expression expression to evaluate\n * @returns {boolean} true if the expression is valid\n */\nfunction isValidExpression(expression) {\n    try {\n        const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n        const fParser = new FormulaParser_1.FormulaParser();\n        const tokens = fTokenizer.execute(expression);\n        return fParser.isValidFormula(tokens);\n    }\n    catch (_a) {\n        return false;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaParser = exports.AstNode = void 0;\nconst constant_1 = require(\"../constant\");\nconst OperatorValue = [...constant_1.ArithmeticOperator, ...constant_1.ComparisonOperator];\n/**\n * Represents a node in the Abstract Syntax Tree (AST).\n */\nclass AstNode {\n    /**\n     * Determines if this node is conditional.\n     * @returns {boolean} True if the node is conditional; otherwise, false.\n     */\n    isConditional() {\n        return !!this.condition && !!this.isFalse && !!this.isTrue;\n    }\n    /**\n     * Determines if this node represents a value.\n     * @returns {boolean} True if the node is a value; otherwise, false.\n     */\n    isValue() {\n        return this.value != undefined;\n    }\n    /**\n     * Determines if this node is a comparison operator.\n     * @returns {boolean} True if the node is a comparison; otherwise, false.\n     */\n    isComparison() {\n        return !!this.isComparisonOperator();\n    }\n    /**\n     * Determines if this node is a field.\n     * @returns {boolean} True if the node is a field; otherwise, false.\n     */\n    isField() {\n        return !!this.fieldName;\n    }\n    /**\n     * Determines if this node is a generic node.\n     * @returns {boolean} True if the node is a node; otherwise, false.\n     */\n    isNode() {\n        return (!this.isValue() &&\n            !this.isField() &&\n            !this.isComparison() &&\n            !this.isConditional());\n    }\n    /**\n     * Checks if the operator is a comparison operator.\n     * @returns {boolean} True if the operator is a comparison operator; otherwise, false.\n     */\n    isComparisonOperator() {\n        if (constant_1.ComparisonOperator.includes(this.operator))\n            return true;\n        return false;\n    }\n}\nexports.AstNode = AstNode;\n/**\n * Parses formulas and generates an Abstract Syntax Tree (AST).\n */\nclass FormulaParser {\n    /**\n     * Checks if the provided tokens represent a valid formula.\n     * @param tokens - An array of tokens representing the formula.\n     * @returns {boolean} True if the tokens form a valid formula; otherwise, false.\n     */\n    isFormula(tokens) {\n        let notOperatorLastIndex = 1;\n        let operatorLastIndex = 1;\n        const operatorRegex = constant_1.REGEX.formulaOperator;\n        for (let index = 0; index < tokens.length; index++) {\n            const token = tokens[index];\n            const isOperator = operatorRegex.test(String(token));\n            const lastIndex = index - 1;\n            if (isOperator) {\n                operatorLastIndex = index;\n            }\n            else {\n                if (notOperatorLastIndex == lastIndex &&\n                    operatorLastIndex != lastIndex) {\n                    return false;\n                }\n                notOperatorLastIndex = index;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks the syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     */\n    checkSyntax(tokens) {\n        this.checkParenthesisSyntax(tokens);\n        this.checkOperatorSyntax(tokens);\n        this.checkTernaryConditionSyntax(tokens);\n    }\n    /**\n     * Checks the parenthesis syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is a parenthesis mismatch.\n     */\n    checkParenthesisSyntax(tokens) {\n        const stack = [];\n        tokens.forEach((token) => {\n            if (token === constant_1.ParenthesisOpenOperator)\n                stack.push(constant_1.ParenthesisOpenOperator);\n            if (token === constant_1.ParenthesisCloseOperator) {\n                if (stack.length === 0) {\n                    throw new Error(\"Parenthesis mismatch\");\n                }\n                stack.pop();\n            }\n        });\n        if (stack.length !== 0) {\n            throw new Error(\"Incorrect parenthesis disposition.\");\n        }\n    }\n    /**\n     * Checks the operator syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is an operator syntax error.\n     */\n    checkOperatorSyntax(tokens) {\n        const regex = /[+-\\/*]{2,}/;\n        const expression = tokens.join(\"\");\n        if (regex.test(expression)) {\n            throw new Error(\"Incorrect Operator error\");\n        }\n        // When tokens length is equal to one and the token is an string or number without operator , just return because is just an operand\n        if (tokens.length == 1 && /\\w/.test(expression))\n            return;\n        const validOperationCheckerRegex = />=|<=|==|!=|&&|\\|\\||[+-\\/*<>%\\^][\\w\\(]/;\n        if (!validOperationCheckerRegex.test(expression)) {\n            throw new Error(\"Incorrect Operator position for Operand\");\n        }\n    }\n    /**\n     * Checks the ternary condition syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is a ternary syntax error.\n     */\n    checkTernaryConditionSyntax(tokens) {\n        let ternaryQuestionMarkCount = 0;\n        let ternaryColonCount = 0;\n        tokens.forEach((token) => {\n            if (token === constant_1.QuestionMarkOperator)\n                ternaryQuestionMarkCount++;\n            if (token === constant_1.ColonOperator)\n                ternaryColonCount++;\n        });\n        if (ternaryQuestionMarkCount !== ternaryColonCount) {\n            throw new Error(\"Incorrect Ternary syntax: unmatched ? and :\");\n        }\n        const ternaryRegex = /[?:]/;\n        let expectingCondition = true;\n        tokens.forEach((token) => {\n            if (ternaryRegex.test(String(token))) {\n                if (expectingCondition && token === constant_1.ColonOperator) {\n                    throw new Error(\"Ternary syntax error: found ':' before '?'\");\n                }\n                expectingCondition = !expectingCondition;\n            }\n        });\n    }\n    /**\n     * Check if the provided tokens is valid formula\n     * @param tokens - An array of tokens to verify if is valid formula\n     * @returns {boolean} return true when is valid formula and false if not\n     */\n    isValidFormula(tokens) {\n        try {\n            if (!this.isFormula(tokens))\n                return false;\n            this.checkSyntax(tokens);\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Executes the parsing of the provided tokens and generates an AST.\n     * @param tokens - An array of tokens to parse.\n     * @returns {Node} The root node of the generated AST.\n     * @throws {Error} Throws an error if the tokens are not a valid formula.\n     */\n    execute(tokens) {\n        if (this.isFormula(tokens)) {\n            this.checkSyntax(tokens);\n            return this.parser(tokens);\n        }\n        else {\n            throw new Error(\"[Error]: Not formula\");\n        }\n    }\n    /**\n     * Parses the provided tokens and generates an AST.\n     * @param tokens - An array of tokens to parse.\n     * @returns {AstNode} The root node of the generated AST.\n     */\n    parser(tokens) {\n        const postFixExpression = this.infixToPostFix(tokens);\n        const result = this.generateAST(postFixExpression);\n        return result;\n    }\n    /**\n     * Generates an Abstract Syntax Tree (AST) from the given tokens.\n     * @param tokens - An array of tokens to generate the AST from.\n     * @returns {AstNode} The root node of the generated AST.\n     */\n    generateAST(tokens) {\n        const stack = [];\n        let counter = 0;\n        return this._generateAST(tokens, counter, stack);\n    }\n    /**\n     * Recursively generates the AST based on the provided tokens and the current index.\n     * @param tokens - An array of tokens to generate the AST from.\n     * @param index - The current index in the tokens array.\n     * @param stack - The stack of nodes being built for the AST.\n     * @returns {AstNode} The root node of the generated AST.\n     */\n    _generateAST(tokens, index, stack = []) {\n        const token = tokens[index];\n        if (token == undefined)\n            return stack[0];\n        if (this.isOperatorFirstAndParenthesis(token)) {\n            const node = new AstNode();\n            node.operator = token;\n            if (this.isArithmeticOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isComparisonOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isTernaryOperator(token)) {\n                node.isFalse = stack.pop();\n                node.isTrue = stack.pop();\n                node.condition = stack.pop();\n            }\n            stack.push(node);\n        }\n        else {\n            const node = new AstNode();\n            if (this.isValue(token)) {\n                node.value = token;\n            }\n            else {\n                node.fieldName = token;\n            }\n            stack.push(node);\n        }\n        return this._generateAST(tokens, index + 1, stack);\n    }\n    /**\n     * Converts infix tokens to postfix notation.\n     * @param tokens - An array of tokens in infix notation.\n     * @returns {(string | number)[]} An array of tokens in postfix notation.\n     */\n    infixToPostFix(tokens) {\n        const output = [];\n        const operators = [];\n        tokens.forEach((token) => {\n            if (!this.isOperatorFirstAndParenthesis(token)) {\n                output.push(token);\n            }\n            else {\n                const operatorAndParenthesis = String(token);\n                const priority = this.priority(operatorAndParenthesis);\n                if (operatorAndParenthesis === constant_1.ParenthesisOpenOperator) {\n                    operators.push(operatorAndParenthesis);\n                }\n                else if (operatorAndParenthesis === constant_1.ParenthesisCloseOperator) {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== constant_1.ParenthesisOpenOperator) {\n                        const operator = operators.pop();\n                        if (!(operator.trim() === constant_1.ParenthesisOpenOperator)) {\n                            output.push(operator);\n                        }\n                    }\n                    operators.pop();\n                }\n                else if (operatorAndParenthesis === constant_1.ColonOperator) {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== constant_1.QuestionMarkOperator) {\n                        output.push(operators.pop());\n                    }\n                }\n                else if (constant_1.Operators.includes(operatorAndParenthesis)) {\n                    while (operators.length > 0 &&\n                        this.priority(operators[operators.length - 1]) >= priority) {\n                        output.push(operators.pop());\n                    }\n                    operators.push(operatorAndParenthesis);\n                }\n                else {\n                }\n            }\n        });\n        while (operators.length > 0) {\n            output.push(operators.pop());\n        }\n        return output;\n    }\n    /**\n     * Determines the priority level of the given operator.\n     *\n     * Operators are assigned the following priority levels:\n     * 1 - Addition and Subtraction\n     * 2 - Multiplication and Division\n     * 3 - Comparison and Logical operators\n     *\n     * @param operator - The operator to evaluate.\n     * @returns {number} The priority level of the operator, where higher numbers indicate higher priority.\n     */\n    priority(operator) {\n        if (constant_1.Priority_1_Operator.includes(operator))\n            return 1;\n        if (constant_1.Priority_2_Operator.includes(operator))\n            return 2;\n        if (constant_1.Priority_3_Operator.includes(operator))\n            return 3;\n        if (constant_1.Priority_4_Operator.includes(operator))\n            return 4;\n        return 0;\n    }\n    /**\n     * Checks if the provided token is an operator or parenthesis.\n     *\n     * This method considers the following tokens as valid operators:\n     * Arithmetic operators: +, -, *, /,^,%\n     * Comparison operators: >, <, >=, <=, ==, !=\n     * Logical operators: ||, &&\n     * Ternary operator: ?\n     * Parentheses: (, )\n     *\n     * @param token - The token to evaluate.\n     * @returns  {boolean} -True if the token is an operator or parenthesis; otherwise, false.\n     */\n    isOperatorFirstAndParenthesis(token) {\n        if (constant_1.AllOperators.includes(String(token).trim()))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is an arithmetic operator.\n     *\n     * The valid arithmetic operators are: +, -, *, /,^,%\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} -True if the token is an arithmetic operator; otherwise, false.\n     */\n    isArithmeticOperator(token) {\n        if (constant_1.ArithmeticOperator.includes(token))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is a comparison operator.\n     *\n     * The valid comparison operators are: >, <, >=, <=, ==, !=, ||, &&\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} -  True if the token is a comparison operator; otherwise, false.\n     */\n    isComparisonOperator(token) {\n        if (constant_1.ComparisonOperator.includes(token))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is a ternary operator.\n     *\n     * The valid ternary operator is: ?\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} - True if the token is a ternary operator; otherwise, false.\n     */\n    isTernaryOperator(token) {\n        return constant_1.QuestionMarkOperator === token;\n    }\n    /**\n     * Checks if the provided token is a valid value.\n     *\n     * A valid value can be a number or a string matching the regex pattern for quoted words.\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} - True if the token is a valid value; otherwise, false.\n     */\n    isValue(token) {\n        const valueRegex = /\"[\\w]+\"/;\n        return typeof token === \"number\" || valueRegex.test(token) ? true : false;\n    }\n}\nexports.FormulaParser = FormulaParser;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaTokenizer = void 0;\nconst constant_1 = require(\"../constant\");\n/**\n * The FormulaTokenizer class is responsible for tokenizing and formatting\n * mathematical expressions for further evaluation. It handles the input\n * string by formatting it, filtering tokens, and preparing them for processing.\n */\nclass FormulaTokenizer {\n    /**\n     * Formats the input string by replacing operators and trimming whitespace.\n     * @param {string} input The input string to be formatted.\n     * @returns {string} The formatted expression.\n     */\n    formatInput(input) {\n        return input\n            .replace(constant_1.REGEX.formulaOperatorG, \" $1 \")\n            .replace(/\\s+/g, \" \")\n            .trim();\n    }\n    /**\n     * Filters the tokens to handle numbers and operators appropriately.\n     * This method processes the tokens to ensure that numbers and operators\n     * are in the correct format for evaluation.\n     * @param {string[]} tokens The array of tokens to be filtered.\n     * @returns {(string | number)[]} The filtered tokens as an array of strings and numbers.\n     */\n    filterTokens(tokens) {\n        const filteredTokens = [];\n        let expectedClosedParenthesis = false;\n        tokens.forEach((token) => {\n            const regex = /^\\d+(\\.\\d+)?$/;\n            const negativeNumberRegex = /-\\d+/;\n            const lastFilteredToken = filteredTokens[filteredTokens.length - 1];\n            if (regex.test(token)) {\n                const firstPop = filteredTokens.pop();\n                const secondPop = filteredTokens.pop();\n                if (firstPop != undefined && secondPop != undefined) {\n                    if (constant_1.Priority_1_Operator.includes(firstPop) &&\n                        secondPop === constant_1.ParenthesisOpenOperator) {\n                        filteredTokens.push(Number(firstPop + token));\n                        expectedClosedParenthesis = true;\n                    }\n                    else {\n                        filteredTokens.push(secondPop, firstPop, Number(token));\n                    }\n                }\n                else {\n                    if (secondPop == undefined) {\n                        if (firstPop != undefined) {\n                            filteredTokens.push(firstPop, Number(token));\n                        }\n                        else {\n                            filteredTokens.push(Number(token));\n                        }\n                    }\n                    else {\n                        filteredTokens.push(Number(token));\n                    }\n                }\n            }\n            else if (negativeNumberRegex.test(lastFilteredToken) &&\n                token === constant_1.ParenthesisCloseOperator &&\n                expectedClosedParenthesis) {\n                expectedClosedParenthesis = false;\n            }\n            else {\n                filteredTokens.push(token);\n            }\n        });\n        return filteredTokens;\n    }\n    /**\n     * Executes the tokenization process for the given input string.\n     * This method formats the input, splits it into tokens,\n     * and filters the tokens to produce a final result.\n     * @param {string} input The input string to be tokenized.\n     * @returns {any[]} The array of filtered tokens resulting from the tokenization process.\n     */\n    execute(input) {\n        const formattedInput = this.formatInput(input);\n        const tokens = formattedInput.split(\" \");\n        const filteredTokens = this.filterTokens(tokens);\n        return filteredTokens;\n    }\n}\nexports.FormulaTokenizer = FormulaTokenizer;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(73);\n"],"names":["root","factory","exports","module","define","amd","this","Object","defineProperty","value","Priority_4_Operator","Priority_3_Operator","Priority_2_Operator","Priority_1_Operator","AllOperators","Operators","ArithmeticOperator","ComparisonOperator","BackslashOperator","QuestionMarkOperator","ColonOperator","ParenthesisCloseOperator","ParenthesisOpenOperator","AssignmentOperator","NotEqualOperator","EqualOperator","LessThanOrEqualOperator","GreaterThanOrEqualOperator","LessThanOperator","GreaterThanOperator","LogicalOrOperator","LogicalAndOperator","ModuloOperator","ExponentialOperator","MultiplicationOperator","DivisionOperator","SubtractionOperator","AdditionOperator","ConditionResult","REGEX","formulaOperatorG","formulaOperator","formulaFieldName","True","False","BinaryOperation","Expression_1","Expression","constructor","left","right","operator","super","execute","obj","ConditionalExpression","condition","isTrue","isFalse","ExpressionConstructor","LiteralValue_1","FieldReference_1","BinaryOperation_1","ConditionalExpression_1","literalValue","LiteralValue","fieldReference","fieldName","FieldReference","addition","a","b","subtraction","multiplication","division","Error","equality","Number","superior","inferior","different","or","and","pow","Math","modulo","constant_1","FormulaParser_1","FormulaTokenizer_1","FormulaInterpreter_1","undefined","isFormulaRef","executeFormulaRef","test","fTokenizer","FormulaTokenizer","fParser","FormulaParser","fInterpreter","FormulaInterpreter","astTree","_value","ownKeys","__createBinding","create","o","m","k","k2","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","__setModuleDefault","v","__importStar","getOwnPropertyNames","ar","prototype","hasOwnProperty","call","length","mod","result","i","isValidExpression","AstNode","ExpressionConstructor_1","main_1","default","data","interpret","isNode","isValue","regex","stringValue","match","isField","fieldValue","String","isComparison","isConditional","comparisonOperator","expression","tokens","isValidFormula","_a","isComparisonOperator","includes","isFormula","notOperatorLastIndex","operatorLastIndex","operatorRegex","index","token","lastIndex","checkSyntax","checkParenthesisSyntax","checkOperatorSyntax","checkTernaryConditionSyntax","stack","forEach","push","pop","join","ternaryQuestionMarkCount","ternaryColonCount","ternaryRegex","expectingCondition","parser","postFixExpression","infixToPostFix","generateAST","_generateAST","isOperatorFirstAndParenthesis","node","isArithmeticOperator","isTernaryOperator","output","operators","operatorAndParenthesis","priority","trim","formatInput","input","replace","filterTokens","filteredTokens","expectedClosedParenthesis","lastFilteredToken","firstPop","secondPop","split","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}