{"version":3,"file":"index.js","mappings":"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","sources":["webpack://smartcal/webpack/universalModuleDefinition","webpack://smartcal/./api/Compile.ts","webpack://smartcal/./api/SmartCal.ts","webpack://smartcal/./api/index.ts","webpack://smartcal/./api/isValidExpression.ts","webpack://smartcal/./constant.ts","webpack://smartcal/./errors/FormulaInterpreterError.ts","webpack://smartcal/./expression/BinaryOperation.ts","webpack://smartcal/./expression/CompiledExpression.ts","webpack://smartcal/./expression/ConditionalExpression.ts","webpack://smartcal/./expression/Expression.ts","webpack://smartcal/./expression/ExpressionConstructor.ts","webpack://smartcal/./expression/FieldReference.ts","webpack://smartcal/./expression/LiteralValue.ts","webpack://smartcal/./index.ts","webpack://smartcal/./interpreter/FormulaInterpreter.ts","webpack://smartcal/./parser/AstNode.ts","webpack://smartcal/./parser/FormulaParser.ts","webpack://smartcal/./tokenizer/FormulaTokenizer.ts","webpack://smartcal/./types/index.ts","webpack://smartcal/webpack/bootstrap","webpack://smartcal/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"smartcal\"] = factory();\n\telse\n\t\troot[\"smartcal\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compile = compile;\nconst CompiledExpression_1 = require(\"../expression/CompiledExpression\");\n/**\n * Compiles a formula expression string into a CompiledExpression object.\n * @param {string} expression - The formula expression to compile\n * @returns {CompiledExpression} A compiled expression that can be evaluated\n * @example\n * const expr = compile(\"age+3\");\n * const result = expr.evaluate({age:18});\n */\nfunction compile(expression) {\n    return new CompiledExpression_1.CompiledFormulaExpression(expression);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SmartCal;\nconst FormulaInterpreter_1 = require(\"../interpreter/FormulaInterpreter\");\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\n/**\n * Evaluates a mathematical expression and returns the result.\n *\n * This function parses and interprets a mathematical formula represented as a string,\n * applying dynamic values from a given object to resolve variables or conditions within the expression.\n *\n * @template T - A generic type representing the structure of the input object. Keys are variable names, and values can be numbers, strings, or arrays.\n * @param {string} expression - The mathematical expression to be evaluated.\n *        Variables in the expression should correspond to keys in the `obj` parameter.\n * @param {T} obj - An object containing the values of the variables referenced in the expression.\n * @returns {number | string | any[]} - The result of the evaluated expression, which can be a number, a string, or an array depending on the expression's logic.\n */\nfunction SmartCal(expression, obj) {\n    const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n    const fParser = new FormulaParser_1.FormulaParser();\n    const fInterpreter = new FormulaInterpreter_1.FormulaInterpreter();\n    return fInterpreter.execute(fParser.execute(fTokenizer.execute(expression)), obj || {});\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = void 0;\nvar SmartCal_1 = require(\"./SmartCal\");\nObject.defineProperty(exports, \"default\", { enumerable: true, get: function () { return __importDefault(SmartCal_1).default; } });\n__exportStar(require(\"./isValidExpression\"), exports);\n__exportStar(require(\"./Compile\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidExpression = isValidExpression;\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\n/**\n * Verify if the given expression is valid formula\n * @param expression expression to evaluate\n * @returns {boolean} true if the expression is valid\n */\nfunction isValidExpression(expression) {\n    try {\n        const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n        const fParser = new FormulaParser_1.FormulaParser();\n        const tokens = fTokenizer.execute(expression);\n        return fParser.isValidFormula(tokens);\n    }\n    catch (_a) {\n        return false;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Priority_4_Operator = exports.Priority_3_Operator = exports.Priority_2_Operator = exports.Priority_1_Operator = exports.AllOperators = exports.Operators = exports.ArithmeticOperator = exports.ComparisonOperator = exports.BackslashOperator = exports.QuestionMarkOperator = exports.ColonOperator = exports.ParenthesisCloseOperator = exports.ParenthesisOpenOperator = exports.AssignmentOperator = exports.NotEqualOperator = exports.EqualOperator = exports.LessThanOrEqualOperator = exports.GreaterThanOrEqualOperator = exports.LessThanOperator = exports.GreaterThanOperator = exports.LogicalOrOperator = exports.LogicalAndOperator = exports.ModuloOperator = exports.ExponentialOperator = exports.MultiplicationOperator = exports.DivisionOperator = exports.SubtractionOperator = exports.AdditionOperator = exports.ConditionResult = exports.REGEX = void 0;\nexports.REGEX = {\n    formulaOperatorG: /(<=|\\^|%|>=|==|\\|\\||&&|!=|[+/\\-*=()<>?:])/g,\n    formulaOperator: /(<=|>=|\\^|%|==|\\|\\||&&|!=|[+/\\-*=()<>?!:])/,\n    formulaFieldName: /f_[\\w]/, // that is regex that identify the formula fieldName\n};\nexports.ConditionResult = {\n    True: 1,\n    False: 0,\n};\n// Arithmetics operators\nexports.AdditionOperator = \"+\";\nexports.SubtractionOperator = \"-\";\nexports.DivisionOperator = \"/\";\nexports.MultiplicationOperator = \"*\";\nexports.ExponentialOperator = \"^\";\nexports.ModuloOperator = \"%\";\n// Logics operators\nexports.LogicalAndOperator = \"&&\";\nexports.LogicalOrOperator = \"||\";\n// Comparisons operators\nexports.GreaterThanOperator = \">\";\nexports.LessThanOperator = \"<\";\nexports.GreaterThanOrEqualOperator = \">=\";\nexports.LessThanOrEqualOperator = \"<=\";\nexports.EqualOperator = \"==\";\nexports.NotEqualOperator = \"!=\";\n// Others operators\nexports.AssignmentOperator = \"=\";\nexports.ParenthesisOpenOperator = \"(\";\nexports.ParenthesisCloseOperator = \")\";\nexports.ColonOperator = \":\";\nexports.QuestionMarkOperator = \"?\";\nexports.BackslashOperator = \"\\\\\";\nexports.ComparisonOperator = [\n    exports.GreaterThanOperator,\n    exports.LessThanOperator,\n    exports.LogicalOrOperator,\n    exports.LogicalAndOperator,\n    exports.GreaterThanOrEqualOperator,\n    exports.LessThanOrEqualOperator,\n    exports.EqualOperator,\n    exports.NotEqualOperator,\n];\nexports.ArithmeticOperator = [\n    exports.AdditionOperator,\n    exports.SubtractionOperator,\n    exports.DivisionOperator,\n    exports.MultiplicationOperator,\n    exports.ExponentialOperator,\n    exports.ModuloOperator,\n];\nexports.Operators = [\n    ...exports.ArithmeticOperator,\n    ...exports.ComparisonOperator,\n    exports.QuestionMarkOperator,\n];\nexports.AllOperators = [\n    ...exports.Operators,\n    exports.ColonOperator,\n    exports.ParenthesisCloseOperator,\n    exports.ParenthesisOpenOperator,\n];\nexports.Priority_1_Operator = [exports.AdditionOperator, exports.SubtractionOperator];\nexports.Priority_2_Operator = [\n    exports.DivisionOperator,\n    exports.MultiplicationOperator,\n    exports.ModuloOperator,\n];\nexports.Priority_3_Operator = [exports.ExponentialOperator];\nexports.Priority_4_Operator = [\n    ...exports.ComparisonOperator,\n    exports.QuestionMarkOperator,\n];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaInterpreterError = void 0;\nclass FormulaInterpreterError {\n    constructor(message, error) {\n        this.message = message;\n        this.name = \"FormulaInterpreterError\";\n        this.stack = error;\n    }\n}\nexports.FormulaInterpreterError = FormulaInterpreterError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BinaryOperation = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a binary operation on two expressions.\n *\n * @template T The input type of the expression.\n * @template R The output type of the expressions.\n * @param {Expression<T, R>} left The left expression.\n * @param {Expression<T, R>} right The right expression.\n * @param {(a: R, b: R) => number} operator The operator function that takes two values of type R and returns a number.\n */\nclass BinaryOperation extends Expression_1.Expression {\n    constructor(left, right, operator) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.operator = operator;\n    }\n    /**\n     * Executes the binary operation on the given object.\n     *\n     * @param {T} obj The object on which the operation will be executed.\n     * @returns {number} The result of the binary operation.\n     */\n    execute(obj) {\n        return this.operator(this.left.execute(obj), this.right.execute(obj));\n    }\n}\nexports.BinaryOperation = BinaryOperation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompiledFormulaExpression = void 0;\nconst FormulaInterpreter_1 = require(\"../interpreter/FormulaInterpreter\");\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\n/**\n * Implementation of the CompiledExpression interface for formula expressions.\n * @class\n * @implements {CompiledExpression}\n */\nclass CompiledFormulaExpression {\n    /**\n     * Creates a new instance of CompiledFormulaExpression.\n     * @param {string} expression - The formula expression to compile\n     */\n    constructor(expression) {\n        this.expression = expression;\n        this.type = \"CompiledExpression\";\n        this._ast = new FormulaParser_1.FormulaParser().execute(new FormulaTokenizer_1.FormulaTokenizer().execute(expression));\n    }\n    /**\n     * Evaluates the expression with the provided data.\n     * @template T\n     * @param {T} data - The data object to evaluate the expression against\n     * @returns {string | number} The result of the evaluation\n     */\n    evaluate(data) {\n        return new FormulaInterpreter_1.FormulaInterpreter().execute(this._ast, data);\n    }\n    /**\n     * Returns the string representation of the expression.\n     * @returns {string} The original expression string\n     */\n    toString() {\n        return this.expression;\n    }\n}\nexports.CompiledFormulaExpression = CompiledFormulaExpression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionalExpression = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a conditional expression that returns values based on a condition.\n *\n * @template T The input type of the expression.\n * @template R The output type of the conditional expression.\n * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.\n * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.\n * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.\n */\nclass ConditionalExpression extends Expression_1.Expression {\n    constructor(condition, isTrue, isFalse) {\n        super();\n        this.condition = condition;\n        this.isTrue = isTrue;\n        this.isFalse = isFalse;\n    }\n    /**\n     * Executes the conditional expression on the given object.\n     *\n     * @param {T} obj The object on which the expression will be evaluated.\n     * @returns {R} The value returned by the conditional expression, based on the evaluation of the condition.\n     */\n    execute(obj) {\n        return this.condition.execute(obj) != 0 ? this.isTrue.execute(obj) : this.isFalse.execute(obj);\n    }\n}\nexports.ConditionalExpression = ConditionalExpression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Expression = void 0;\n/**\n * Represents an abstract expression that defines an interface for evaluating expressions.\n * @template T The input type for the expression.\n * @template R The type of result produced by the expression.\n */\nclass Expression {\n}\nexports.Expression = Expression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExpressionConstructor = void 0;\nconst LiteralValue_1 = require(\"./LiteralValue\");\nconst FieldReference_1 = require(\"./FieldReference\");\nconst BinaryOperation_1 = require(\"./BinaryOperation\");\nconst ConditionalExpression_1 = require(\"./ConditionalExpression\");\nclass ExpressionConstructor {\n    /**\n     * Creates a literal value expression.\n     *\n     * @template T The input type of the expression.\n     * @template R The output type of the literal value.\n     * @param {R} value The value to be represented as a literal.\n     * @returns {Expression<T, R>} The literal value expression.\n     */\n    static literalValue(value) {\n        return new LiteralValue_1.LiteralValue(value);\n    }\n    /**\n     * Creates a field reference expression based on the provided field name.\n     *\n     * @template T The type of the input object.\n     * @template R The type of the output value from the field.\n     * @param {string} fieldName The name of the field to reference.\n     * @returns {Expression<T, R>} The field reference expression.\n     */\n    static fieldReference(fieldName) {\n        return new FieldReference_1.FieldReference(fieldName);\n    }\n    /**\n     * Creates an addition operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The addition expression.\n     */\n    static addition(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a + b);\n    }\n    /**\n     * Creates a subtraction operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The subtraction expression.\n     */\n    static subtraction(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a - b);\n    }\n    /**\n     * Creates a multiplication operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The multiplication expression.\n     */\n    static multiplication(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a * b);\n    }\n    /**\n     * Creates a division operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The division expression.\n     * @throws {Error} Throws an error if division by zero is attempted.\n     */\n    static division(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => {\n            if (b === 0)\n                throw new Error(\"Division by zero\");\n            return a / b;\n        });\n    }\n    /**\n     * Creates a conditional expression based on the specified condition.\n     *\n     * @template T The input type of the expression.\n     * @template R The output type of the conditional expression.\n     * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.\n     * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.\n     * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.\n     * @returns {Expression<T, R>} The conditional expression.\n     */\n    static condition(condition, isTrue, isFalse) {\n        return new ConditionalExpression_1.ConditionalExpression(condition, isTrue, isFalse);\n    }\n    /**\n     * Creates an equality expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The equality expression.\n     */\n    static equality(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a === b));\n    }\n    /**\n     * Creates a greater-than expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The greater-than expression.\n     */\n    static superior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a > b));\n    }\n    /**\n     * Creates a less-than expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The less-than expression.\n     */\n    static inferior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a < b));\n    }\n    /**\n     * Creates a not-equal expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The not-equal expression.\n     */\n    static different(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a != b));\n    }\n    /**\n     * Creates a logical OR expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The logical OR expression.\n     */\n    static or(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a || b));\n    }\n    /**\n     * Creates a logical AND expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The logical AND expression.\n     */\n    static and(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a && b));\n    }\n    /**\n     * Creates a power (exponentiation) expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @param {Expression<T, number>} base The base operand.\n     * @param {Expression<T, number>} exponent The exponent operand.\n     * @returns {Expression<T, number>} The result of raising `base` to the power of `right`.\n     */\n    static pow(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Math.pow(Number(a), Number(b)));\n    }\n    /**\n     * Creates a modulo operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The modulo expression.\n     */\n    static modulo(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a % b);\n    }\n}\nexports.ExpressionConstructor = ExpressionConstructor;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FieldReference = void 0;\nconst Expression_1 = require(\"./Expression\");\nconst constant_1 = require(\"./../constant\");\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\nconst FormulaInterpreter_1 = require(\"../interpreter/FormulaInterpreter\");\n/**\n * Represents a reference to a field in a given object, allowing\n * for the execution of expressions and the interpretation of formulas.\n *\n * @template T - The type of the object containing the fields.\n * @template R - The type of the return value of the expression.\n * @param {string} fieldName - The name of the field to reference in the object.\n */\nclass FieldReference extends Expression_1.Expression {\n    constructor(fieldName) {\n        super();\n        this.fieldName = fieldName;\n    }\n    /**\n     * Executes the field reference on the given object.\n     *\n     * @param {T} obj - The object from which to extract the field value.\n     * @returns {R} The value of the referenced field.\n     * @throws {Error} If the field does not exist or is undefined in the object.\n     */\n    execute(obj) {\n        if (obj != null && obj != undefined) {\n            if (obj[this.fieldName] != undefined) {\n                if (this.isFormulaRef())\n                    return this.executeFormulaRef(obj);\n                if (this.isCompiledExpression(obj))\n                    return this.evaluateCompiledExpression(obj);\n                return obj[this.fieldName];\n            }\n        }\n        throw new Error(`The fieldName ${this.fieldName} does not exist or is undefined on object ${obj}`);\n    }\n    /**\n     * Checks if the field name corresponds to a formula reference.\n     *\n     * @returns {boolean} True if the field is a formula reference, otherwise false.\n     */\n    isFormulaRef() {\n        return constant_1.REGEX.formulaFieldName.test(this.fieldName);\n    }\n    /**\n     * Checks if the field name corresponds to a Compiled Expression\n     * @param obj {T} The object from which to extract the field value.\n     * @returns {boolean}  True if the field is a formula reference, otherwise false.\n     */\n    isCompiledExpression(obj) {\n        var _a;\n        return ((_a = obj[this.fieldName]) === null || _a === void 0 ? void 0 : _a.type) === \"CompiledExpression\";\n    }\n    /**\n     * Executes the formula reference and returns the result of the interpretation.\n     *\n     * @param {T} obj - The object from which to extract the formula.\n     * @returns {R} The result of executing the formula.\n     */\n    executeFormulaRef(obj) {\n        const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n        const fParser = new FormulaParser_1.FormulaParser();\n        const fInterpreter = new FormulaInterpreter_1.FormulaInterpreter();\n        const astTree = fParser.execute(fTokenizer.execute(obj[this.fieldName]));\n        return fInterpreter.execute(astTree, obj);\n    }\n    /**\n     * Evaluate the compiled Expression\n     * @param obj - The object from which to extract the formula.\n     * @returns The result of evaluate the compiled Expression.\n     */\n    evaluateCompiledExpression(obj) {\n        const compiledExpression = obj[this.fieldName];\n        return compiledExpression.evaluate(obj);\n    }\n}\nexports.FieldReference = FieldReference;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiteralValue = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a literal value expression.\n *\n * @template T The input type of the expression.\n * @template R The output type of the expression, defaulting to number.\n * @param {R} _value The literal value to be returned when executed.\n */\nclass LiteralValue extends Expression_1.Expression {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    /**\n     * Executes the literal value expression and returns the value.\n     *\n     * @param {T} obj The object on which the expression is executed (not used in this case).\n     * @returns {R} The literal value.\n     */\n    execute(obj) {\n        return this._value;\n    }\n}\nexports.LiteralValue = LiteralValue;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionResult = exports.isValidExpression = exports.compile = exports.default = void 0;\nconst constant_1 = require(\"./constant\");\nObject.defineProperty(exports, \"ConditionResult\", { enumerable: true, get: function () { return constant_1.ConditionResult; } });\nvar api_1 = require(\"./api\");\nObject.defineProperty(exports, \"default\", { enumerable: true, get: function () { return __importDefault(api_1).default; } });\nObject.defineProperty(exports, \"compile\", { enumerable: true, get: function () { return api_1.compile; } });\nObject.defineProperty(exports, \"isValidExpression\", { enumerable: true, get: function () { return api_1.isValidExpression; } });\n__exportStar(require(\"./types\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaInterpreter = void 0;\nconst ExpressionConstructor_1 = require(\"./../expression/ExpressionConstructor\");\nconst constant_1 = require(\"../constant\");\nconst FormulaInterpreterError_1 = require(\"../errors/FormulaInterpreterError\");\n/**\n * The FormulaInterpreter class is responsible for interpreting an abstract syntax tree (AST)\n * representing a mathematical or logical expression. It evaluates expressions based on provided\n * variable data and constructs appropriate expression objects for processing.\n */\nclass FormulaInterpreter {\n    /**\n     * Executes the interpretation of the AST tree and returns the evaluated result.\n     * @param {INode} astTree The abstract syntax tree to be interpreted.\n     * @param {T} data The variable data to use for evaluation.\n     * @returns {number | string} The result of the expression evaluation.\n     */\n    execute(astTree, data) {\n        const result = this.interpret(astTree, data).execute(data);\n        return result;\n    }\n    /**\n     * Interprets the AST tree recursively and constructs expression objects based on the node types.\n     * @param {INode} astTree The abstract syntax tree to interpret.\n     * @param {T} data The variable data to use for evaluation.\n     * @returns {Expression<T, string | number>} The constructed expression object.\n     */\n    interpret(astTree, data) {\n        try {\n            if (astTree.isNode()) {\n                const operator = astTree.operator;\n                const right = this.interpret(astTree.right, data);\n                const left = this.interpret(astTree.left, data);\n                switch (operator) {\n                    case constant_1.AdditionOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.addition(left, right);\n                    case constant_1.SubtractionOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.subtraction(left, right);\n                    case constant_1.MultiplicationOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.multiplication(left, right);\n                    case constant_1.DivisionOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.division(left, right);\n                    case constant_1.ModuloOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.modulo(left, right);\n                    case constant_1.ExponentialOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.pow(left, right);\n                    default:\n                        throw new Error(`This operator ${operator} is not supported.`);\n                }\n            }\n            else if (astTree.isValue()) {\n                const value = astTree.value;\n                if (typeof value === \"number\") {\n                    return ExpressionConstructor_1.ExpressionConstructor.literalValue(Number(astTree.value));\n                }\n                else {\n                    const regex = /[\"']([\\w]+)[\"']/;\n                    const stringValue = value.match(regex)[1];\n                    return ExpressionConstructor_1.ExpressionConstructor.literalValue(stringValue);\n                }\n            }\n            else if (astTree.isField()) {\n                const fieldValue = data[String(astTree.fieldName)];\n                if (fieldValue === undefined)\n                    throw new FormulaInterpreterError_1.FormulaInterpreterError(`The variable ${astTree.fieldName} not defined.`);\n                if (typeof fieldValue === \"number\") {\n                    return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n                }\n                else {\n                    return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n                }\n            }\n            else if (astTree.isComparison()) {\n                const comparisonOperator = astTree.operator;\n                const left = this.interpret(astTree.left, data);\n                const right = this.interpret(astTree.right, data);\n                switch (comparisonOperator) {\n                    case constant_1.GreaterThanOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.superior(left, right);\n                    case constant_1.LessThanOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.inferior(left, right);\n                    case constant_1.EqualOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.equality(left, right);\n                    case constant_1.GreaterThanOrEqualOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.superior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                    case constant_1.LessThanOrEqualOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.inferior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                    case constant_1.LogicalOrOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.or(left, right);\n                    case constant_1.LogicalAndOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.and(left, right);\n                    case constant_1.NotEqualOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.different(left, right);\n                    default:\n                        throw new FormulaInterpreterError_1.FormulaInterpreterError(`This comparison ${comparisonOperator} method is not supported`);\n                }\n            }\n            else if (astTree.isConditional()) {\n                const condition = this.interpret(astTree.condition, data);\n                const isTrue = this.interpret(astTree.isTrue, data);\n                const isFalse = this.interpret(astTree.isFalse, data);\n                return ExpressionConstructor_1.ExpressionConstructor.condition(condition, isTrue, isFalse);\n            }\n            else {\n                throw new FormulaInterpreterError_1.FormulaInterpreterError(`This Expression is not Correct. Please verify Your expression [Interpreter]:${astTree}`);\n            }\n        }\n        catch (e) {\n            throw e;\n        }\n    }\n}\nexports.FormulaInterpreter = FormulaInterpreter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AstNode = void 0;\nconst constant_1 = require(\"../constant\");\n/**\n * Represents a node in the Abstract Syntax Tree (AST).\n */\nclass AstNode {\n    /**\n     * Determines if this node is conditional.\n     * @returns {boolean} True if the node is conditional; otherwise, false.\n     */\n    isConditional() {\n        return !!this.condition && !!this.isFalse && !!this.isTrue;\n    }\n    /**\n     * Determines if this node represents a value.\n     * @returns {boolean} True if the node is a value; otherwise, false.\n     */\n    isValue() {\n        return this.value != undefined;\n    }\n    /**\n     * Determines if this node is a comparison operator.\n     * @returns {boolean} True if the node is a comparison; otherwise, false.\n     */\n    isComparison() {\n        return !!this.isComparisonOperator();\n    }\n    /**\n     * Determines if this node is a field.\n     * @returns {boolean} True if the node is a field; otherwise, false.\n     */\n    isField() {\n        return !!this.fieldName;\n    }\n    /**\n     * Determines if this node is a generic node.\n     * @returns {boolean} True if the node is a node; otherwise, false.\n     */\n    isNode() {\n        return (!this.isValue() &&\n            !this.isField() &&\n            !this.isComparison() &&\n            !this.isConditional());\n    }\n    /**\n     * Checks if the operator is a comparison operator.\n     * @returns {boolean} True if the operator is a comparison operator; otherwise, false.\n     */\n    isComparisonOperator() {\n        if (constant_1.ComparisonOperator.includes(this.operator))\n            return true;\n        return false;\n    }\n}\nexports.AstNode = AstNode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaParser = void 0;\nconst constant_1 = require(\"../constant\");\nconst AstNode_1 = require(\"./AstNode\");\n/**\n * Parses formulas and generates an Abstract Syntax Tree (AST).\n */\nclass FormulaParser {\n    /**\n     * Checks if the provided tokens represent a valid formula.\n     * @param tokens - An array of tokens representing the formula.\n     * @returns {boolean} True if the tokens form a valid formula; otherwise, false.\n     */\n    isFormula(tokens) {\n        let notOperatorLastIndex = 1;\n        let operatorLastIndex = 1;\n        const operatorRegex = constant_1.REGEX.formulaOperator;\n        for (let index = 0; index < tokens.length; index++) {\n            const token = tokens[index];\n            const isOperator = operatorRegex.test(String(token));\n            const lastIndex = index - 1;\n            if (isOperator) {\n                operatorLastIndex = index;\n            }\n            else {\n                if (notOperatorLastIndex == lastIndex &&\n                    operatorLastIndex != lastIndex) {\n                    return false;\n                }\n                notOperatorLastIndex = index;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks the syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     */\n    checkSyntax(tokens) {\n        this.checkParenthesisSyntax(tokens);\n        this.checkOperatorSyntax(tokens);\n        this.checkTernaryConditionSyntax(tokens);\n    }\n    /**\n     * Checks the parenthesis syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is a parenthesis mismatch.\n     */\n    checkParenthesisSyntax(tokens) {\n        const stack = [];\n        tokens.forEach((token) => {\n            if (token === constant_1.ParenthesisOpenOperator)\n                stack.push(constant_1.ParenthesisOpenOperator);\n            if (token === constant_1.ParenthesisCloseOperator) {\n                if (stack.length === 0) {\n                    throw new Error(\"Parenthesis mismatch\");\n                }\n                stack.pop();\n            }\n        });\n        if (stack.length !== 0) {\n            throw new Error(\"Incorrect parenthesis disposition.\");\n        }\n    }\n    /**\n     * Checks the operator syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is an operator syntax error.\n     */\n    checkOperatorSyntax(tokens) {\n        const regex = /[+-\\/*]{2,}/;\n        const expression = tokens.join(\"\");\n        if (regex.test(expression)) {\n            throw new Error(\"Incorrect Operator error\");\n        }\n        // When tokens length is equal to one and the token is an string or number without operator , just return because is just an operand\n        if (tokens.length == 1 && /\\w/.test(expression))\n            return;\n        const validOperationCheckerRegex = />=|<=|==|!=|&&|\\|\\||[+-\\/*<>%\\^][\\w\\(]/;\n        if (!validOperationCheckerRegex.test(expression)) {\n            throw new Error(\"Incorrect Operator position for Operand\");\n        }\n    }\n    /**\n     * Checks the ternary condition syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {Error} Throws an error if there is a ternary syntax error.\n     */\n    checkTernaryConditionSyntax(tokens) {\n        let ternaryQuestionMarkCount = 0;\n        let ternaryColonCount = 0;\n        tokens.forEach((token) => {\n            if (token === constant_1.QuestionMarkOperator)\n                ternaryQuestionMarkCount++;\n            if (token === constant_1.ColonOperator)\n                ternaryColonCount++;\n        });\n        if (ternaryQuestionMarkCount !== ternaryColonCount) {\n            throw new Error(\"Incorrect Ternary syntax: unmatched ? and :\");\n        }\n        const ternaryRegex = /[?:]/;\n        let expectingCondition = true;\n        tokens.forEach((token) => {\n            if (ternaryRegex.test(String(token))) {\n                if (expectingCondition && token === constant_1.ColonOperator) {\n                    throw new Error(\"Ternary syntax error: found ':' before '?'\");\n                }\n                expectingCondition = !expectingCondition;\n            }\n        });\n    }\n    /**\n     * Check if the provided tokens is valid formula\n     * @param tokens - An array of tokens to verify if is valid formula\n     * @returns {boolean} return true when is valid formula and false if not\n     */\n    isValidFormula(tokens) {\n        try {\n            if (!this.isFormula(tokens))\n                return false;\n            this.checkSyntax(tokens);\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Executes the parsing of the provided tokens and generates an AST.\n     * @param tokens - An array of tokens to parse.\n     * @returns {INode} The root node of the generated AST.\n     * @throws {Error} Throws an error if the tokens are not a valid formula.\n     */\n    execute(tokens) {\n        if (tokens.length != 0 && this.isFormula(tokens)) {\n            this.checkSyntax(tokens);\n            return this.parser(tokens);\n        }\n        else {\n            throw new Error(\"[Error]: Not formula\");\n        }\n    }\n    /**\n     * Parses the provided tokens and generates an AST.\n     * @param tokens - An array of tokens to parse.\n     * @returns {INode} The root node of the generated AST.\n     */\n    parser(tokens) {\n        const postFixExpression = this.infixToPostFix(tokens);\n        const result = this.generateAST(postFixExpression);\n        return result;\n    }\n    /**\n     * Generates an Abstract Syntax Tree (AST) from the given tokens.\n     * @param tokens - An array of tokens to generate the AST from.\n     * @returns {INode} The root node of the generated AST.\n     */\n    generateAST(tokens) {\n        const stack = [];\n        let counter = 0;\n        return this._generateAST(tokens, counter, stack);\n    }\n    /**\n     * Recursively generates the AST based on the provided tokens and the current index.\n     * @param tokens - An array of tokens to generate the AST from.\n     * @param index - The current index in the tokens array.\n     * @param stack - The stack of nodes being built for the AST.\n     * @returns {INode} The root node of the generated AST.\n     */\n    _generateAST(tokens, index, stack = []) {\n        const token = tokens[index];\n        if (token == undefined)\n            return stack[0];\n        if (this.isOperatorFirstAndParenthesis(token)) {\n            const node = new AstNode_1.AstNode();\n            node.operator = token;\n            if (this.isArithmeticOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isComparisonOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isTernaryOperator(token)) {\n                node.isFalse = stack.pop();\n                node.isTrue = stack.pop();\n                node.condition = stack.pop();\n            }\n            stack.push(node);\n        }\n        else {\n            const node = new AstNode_1.AstNode();\n            if (this.isValue(token)) {\n                node.value = token;\n            }\n            else {\n                node.fieldName = token;\n            }\n            stack.push(node);\n        }\n        return this._generateAST(tokens, index + 1, stack);\n    }\n    /**\n     * Converts infix tokens to postfix notation.\n     * @param tokens - An array of tokens in infix notation.\n     * @returns {(string | number)[]} An array of tokens in postfix notation.\n     */\n    infixToPostFix(tokens) {\n        const output = [];\n        const operators = [];\n        tokens.forEach((token) => {\n            if (!this.isOperatorFirstAndParenthesis(token)) {\n                output.push(token);\n            }\n            else {\n                const operatorAndParenthesis = String(token);\n                const priority = this.priority(operatorAndParenthesis);\n                if (operatorAndParenthesis === constant_1.ParenthesisOpenOperator) {\n                    operators.push(operatorAndParenthesis);\n                }\n                else if (operatorAndParenthesis === constant_1.ParenthesisCloseOperator) {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== constant_1.ParenthesisOpenOperator) {\n                        const operator = operators.pop();\n                        if (!(operator.trim() === constant_1.ParenthesisOpenOperator)) {\n                            output.push(operator);\n                        }\n                    }\n                    operators.pop();\n                }\n                else if (operatorAndParenthesis === constant_1.ColonOperator) {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== constant_1.QuestionMarkOperator) {\n                        output.push(operators.pop());\n                    }\n                }\n                else if (constant_1.Operators.includes(operatorAndParenthesis)) {\n                    while (operators.length > 0 &&\n                        this.priority(operators[operators.length - 1]) >= priority) {\n                        output.push(operators.pop());\n                    }\n                    operators.push(operatorAndParenthesis);\n                }\n                else {\n                }\n            }\n        });\n        while (operators.length > 0) {\n            output.push(operators.pop());\n        }\n        return output;\n    }\n    /**\n     * Determines the priority level of the given operator.\n     *\n     * Operators are assigned the following priority levels:\n     * 1 - Addition and Subtraction\n     * 2 - Multiplication and Division\n     * 3 - Comparison and Logical operators\n     *\n     * @param operator - The operator to evaluate.\n     * @returns {number} The priority level of the operator, where higher numbers indicate higher priority.\n     */\n    priority(operator) {\n        if (constant_1.Priority_1_Operator.includes(operator))\n            return 1;\n        if (constant_1.Priority_2_Operator.includes(operator))\n            return 2;\n        if (constant_1.Priority_3_Operator.includes(operator))\n            return 3;\n        if (constant_1.Priority_4_Operator.includes(operator))\n            return 4;\n        return 0;\n    }\n    /**\n     * Checks if the provided token is an operator or parenthesis.\n     *\n     * This method considers the following tokens as valid operators:\n     * Arithmetic operators: +, -, *, /,^,%\n     * Comparison operators: >, <, >=, <=, ==, !=\n     * Logical operators: ||, &&\n     * Ternary operator: ?\n     * Parentheses: (, )\n     *\n     * @param token - The token to evaluate.\n     * @returns  {boolean} -True if the token is an operator or parenthesis; otherwise, false.\n     */\n    isOperatorFirstAndParenthesis(token) {\n        if (constant_1.AllOperators.includes(String(token).trim()))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is an arithmetic operator.\n     *\n     * The valid arithmetic operators are: +, -, *, /,^,%\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} -True if the token is an arithmetic operator; otherwise, false.\n     */\n    isArithmeticOperator(token) {\n        if (constant_1.ArithmeticOperator.includes(token))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is a comparison operator.\n     *\n     * The valid comparison operators are: >, <, >=, <=, ==, !=, ||, &&\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} -  True if the token is a comparison operator; otherwise, false.\n     */\n    isComparisonOperator(token) {\n        if (constant_1.ComparisonOperator.includes(token))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is a ternary operator.\n     *\n     * The valid ternary operator is: ?\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} - True if the token is a ternary operator; otherwise, false.\n     */\n    isTernaryOperator(token) {\n        return constant_1.QuestionMarkOperator === token;\n    }\n    /**\n     * Checks if the provided token is a valid value.\n     *\n     * A valid value can be a number or a string matching the regex pattern for quoted words.\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} - True if the token is a valid value; otherwise, false.\n     */\n    isValue(token) {\n        const valueRegex = /[\"'][\\w]+[\"']/;\n        return typeof token === \"number\" || valueRegex.test(token) ? true : false;\n    }\n}\nexports.FormulaParser = FormulaParser;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaTokenizer = void 0;\nconst constant_1 = require(\"../constant\");\n/**\n * The FormulaTokenizer class is responsible for tokenizing and formatting\n * mathematical expressions for further evaluation. It handles the input\n * string by formatting it, filtering tokens, and preparing them for processing.\n */\nclass FormulaTokenizer {\n    /**\n     * Formats the input string by replacing operators and trimming whitespace.\n     * @param {string} input The input string to be formatted.\n     * @returns {string} The formatted expression.\n     */\n    formatInput(input) {\n        return input\n            .replace(constant_1.REGEX.formulaOperatorG, \" $1 \")\n            .replace(/\\s+/g, \" \")\n            .trim();\n    }\n    /**\n     * Filters the tokens to handle numbers and operators appropriately.\n     * This method processes the tokens to ensure that numbers and operators\n     * are in the correct format for evaluation.\n     * @param {string[]} tokens The array of tokens to be filtered.\n     * @returns {(string | number)[]} The filtered tokens as an array of strings and numbers.\n     */\n    filterTokens(tokens) {\n        const filteredTokens = [];\n        let expectedClosedParenthesis = false;\n        tokens.forEach((token) => {\n            const regex = /^\\d+(\\.\\d+)?$/;\n            const negativeNumberRegex = /-\\d+/;\n            const lastFilteredToken = filteredTokens[filteredTokens.length - 1];\n            if (regex.test(token)) {\n                const firstPop = filteredTokens.pop();\n                const secondPop = filteredTokens.pop();\n                if (firstPop != undefined && secondPop != undefined) {\n                    if (constant_1.Priority_1_Operator.includes(firstPop) &&\n                        secondPop === constant_1.ParenthesisOpenOperator) {\n                        filteredTokens.push(Number(firstPop + token));\n                        expectedClosedParenthesis = true;\n                    }\n                    else {\n                        filteredTokens.push(secondPop, firstPop, Number(token));\n                    }\n                }\n                else {\n                    if (secondPop == undefined) {\n                        if (firstPop != undefined) {\n                            filteredTokens.push(firstPop, Number(token));\n                        }\n                        else {\n                            filteredTokens.push(Number(token));\n                        }\n                    }\n                    else {\n                        filteredTokens.push(Number(token));\n                    }\n                }\n            }\n            else if (negativeNumberRegex.test(lastFilteredToken) &&\n                token === constant_1.ParenthesisCloseOperator &&\n                expectedClosedParenthesis) {\n                expectedClosedParenthesis = false;\n            }\n            else {\n                filteredTokens.push(token);\n            }\n        });\n        return filteredTokens;\n    }\n    /**\n     * Executes the tokenization process for the given input string.\n     * This method formats the input, splits it into tokens,\n     * and filters the tokens to produce a final result.\n     * @param {string} input The input string to be tokenized.\n     * @returns {any[]} The array of filtered tokens resulting from the tokenization process.\n     */\n    execute(input) {\n        const formattedInput = this.formatInput(input);\n        if (formattedInput.trim() === \"\")\n            return [];\n        const tokens = formattedInput.split(\" \");\n        const filteredTokens = this.filterTokens(tokens);\n        return filteredTokens;\n    }\n}\nexports.FormulaTokenizer = FormulaTokenizer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constant_1 = require(\"../constant\");\nconst OperatorValue = [...constant_1.ArithmeticOperator, ...constant_1.ComparisonOperator];\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(73);\n"],"names":["root","factory","exports","module","define","amd","this","Object","defineProperty","value","compile","expression","CompiledExpression_1","CompiledFormulaExpression","obj","fTokenizer","FormulaTokenizer_1","FormulaTokenizer","fParser","FormulaParser_1","FormulaParser","FormulaInterpreter_1","FormulaInterpreter","execute","__createBinding","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","__exportStar","p","prototype","hasOwnProperty","call","__importDefault","mod","SmartCal_1","default","isValidExpression","tokens","isValidFormula","_a","Priority_4_Operator","Priority_3_Operator","Priority_2_Operator","Priority_1_Operator","AllOperators","Operators","ArithmeticOperator","ComparisonOperator","BackslashOperator","QuestionMarkOperator","ColonOperator","ParenthesisCloseOperator","ParenthesisOpenOperator","AssignmentOperator","NotEqualOperator","EqualOperator","LessThanOrEqualOperator","GreaterThanOrEqualOperator","LessThanOperator","GreaterThanOperator","LogicalOrOperator","LogicalAndOperator","ModuloOperator","ExponentialOperator","MultiplicationOperator","DivisionOperator","SubtractionOperator","AdditionOperator","ConditionResult","REGEX","formulaOperatorG","formulaOperator","formulaFieldName","True","False","FormulaInterpreterError","constructor","message","error","name","stack","BinaryOperation","Expression_1","Expression","left","right","operator","super","type","_ast","evaluate","data","toString","ConditionalExpression","condition","isTrue","isFalse","ExpressionConstructor","LiteralValue_1","FieldReference_1","BinaryOperation_1","ConditionalExpression_1","literalValue","LiteralValue","fieldReference","fieldName","FieldReference","addition","a","b","subtraction","multiplication","division","Error","equality","Number","superior","inferior","different","or","and","pow","Math","modulo","constant_1","isFormulaRef","executeFormulaRef","isCompiledExpression","evaluateCompiledExpression","test","fInterpreter","astTree","_value","api_1","ExpressionConstructor_1","FormulaInterpreterError_1","interpret","isNode","isValue","regex","stringValue","match","isField","fieldValue","String","isComparison","isConditional","comparisonOperator","e","AstNode","isComparisonOperator","includes","AstNode_1","isFormula","notOperatorLastIndex","operatorLastIndex","operatorRegex","index","length","token","lastIndex","checkSyntax","checkParenthesisSyntax","checkOperatorSyntax","checkTernaryConditionSyntax","forEach","push","pop","join","ternaryQuestionMarkCount","ternaryColonCount","ternaryRegex","expectingCondition","parser","postFixExpression","infixToPostFix","generateAST","_generateAST","isOperatorFirstAndParenthesis","node","isArithmeticOperator","isTernaryOperator","output","operators","operatorAndParenthesis","priority","trim","formatInput","input","replace","filterTokens","filteredTokens","expectedClosedParenthesis","lastFilteredToken","firstPop","secondPop","formattedInput","split","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}