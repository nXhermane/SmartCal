{"version":3,"file":"index.js","mappings":"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","sources":["webpack://smartcal/webpack/universalModuleDefinition","webpack://smartcal/./api/Compile.ts","webpack://smartcal/./api/SmartCal.ts","webpack://smartcal/./api/index.ts","webpack://smartcal/./api/isValidExpression.ts","webpack://smartcal/./constant.ts","webpack://smartcal/./errors/FormulaInterpreterError.ts","webpack://smartcal/./errors/FormulaVariableNotFoundError.ts","webpack://smartcal/./errors/IncorrectSyntax.ts","webpack://smartcal/./errors/InvalidFormulaError.ts","webpack://smartcal/./errors/index.ts","webpack://smartcal/./expression/BinaryOperation.ts","webpack://smartcal/./expression/CompiledExpression.ts","webpack://smartcal/./expression/ConditionalExpression.ts","webpack://smartcal/./expression/Expression.ts","webpack://smartcal/./expression/ExpressionConstructor.ts","webpack://smartcal/./expression/FieldReference.ts","webpack://smartcal/./expression/LiteralValue.ts","webpack://smartcal/./index.ts","webpack://smartcal/./interpreter/FormulaInterpreter.ts","webpack://smartcal/./parser/AstNode.ts","webpack://smartcal/./parser/FormulaParser.ts","webpack://smartcal/./tokenizer/FormulaTokenizer.ts","webpack://smartcal/./types/index.ts","webpack://smartcal/webpack/bootstrap","webpack://smartcal/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"smartcal\"] = factory();\n\telse\n\t\troot[\"smartcal\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compile = compile;\nconst CompiledExpression_1 = require(\"../expression/CompiledExpression\");\n/**\n * Compiles a formula expression string into a CompiledExpression object.\n * @param {string} expression - The formula expression to compile\n * @returns {CompiledExpression} A compiled expression that can be evaluated\n * @example\n * const expr = compile(\"age+3\");\n * const result = expr.evaluate({age:18});\n */\nfunction compile(expression) {\n    return new CompiledExpression_1.CompiledFormulaExpression(expression);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SmartCal;\nconst FormulaInterpreter_1 = require(\"../interpreter/FormulaInterpreter\");\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\n/**\n * Evaluates a mathematical expression and returns the result.\n *\n * This function parses and interprets a mathematical formula represented as a string,\n * applying dynamic values from a given object to resolve variables or conditions within the expression.\n *\n * @template T - A generic type representing the structure of the input object. Keys are variable names, and values can be numbers, strings, or arrays.\n * @param {string} expression - The mathematical expression to be evaluated.\n *        Variables in the expression should correspond to keys in the `obj` parameter.\n * @param {T} obj - An object containing the values of the variables referenced in the expression.\n * @returns {number | string | any[]} - The result of the evaluated expression, which can be a number, a string, or an array depending on the expression's logic.\n */\nfunction SmartCal(expression, obj) {\n    const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n    const fParser = new FormulaParser_1.FormulaParser();\n    const fInterpreter = new FormulaInterpreter_1.FormulaInterpreter();\n    return fInterpreter.execute(fParser.execute(fTokenizer.execute(expression)), obj || {});\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = void 0;\nvar SmartCal_1 = require(\"./SmartCal\");\nObject.defineProperty(exports, \"default\", { enumerable: true, get: function () { return __importDefault(SmartCal_1).default; } });\n__exportStar(require(\"./isValidExpression\"), exports);\n__exportStar(require(\"./Compile\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidExpression = isValidExpression;\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\n/**\n * Verify if the given expression is valid formula\n * @param expression expression to evaluate\n * @returns {boolean} true if the expression is valid\n */\nfunction isValidExpression(expression) {\n    try {\n        const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n        const fParser = new FormulaParser_1.FormulaParser();\n        const tokens = fTokenizer.execute(expression);\n        return fParser.isValidFormula(tokens);\n    }\n    catch (_a) {\n        return false;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Priority_4_Operator = exports.Priority_3_Operator = exports.Priority_2_Operator = exports.Priority_1_Operator = exports.AllOperators = exports.Operators = exports.ArithmeticOperator = exports.ComparisonOperator = exports.BackslashOperator = exports.QuestionMarkOperator = exports.ColonOperator = exports.ParenthesisCloseOperator = exports.ParenthesisOpenOperator = exports.AssignmentOperator = exports.NotEqualOperator = exports.EqualOperator = exports.LessThanOrEqualOperator = exports.GreaterThanOrEqualOperator = exports.LessThanOperator = exports.GreaterThanOperator = exports.LogicalOrOperator = exports.LogicalAndOperator = exports.ModuloOperator = exports.ExponentialOperator = exports.MultiplicationOperator = exports.DivisionOperator = exports.SubtractionOperator = exports.AdditionOperator = exports.ConditionResult = exports.REGEX = void 0;\nexports.REGEX = {\n    formulaOperatorG: /(<=|\\^|%|>=|==|\\|\\||&&|!=|[+/\\-*=()<>?:])/g,\n    formulaOperator: /(<=|>=|\\^|%|==|\\|\\||&&|!=|[+/\\-*=()<>?!:])/,\n    formulaFieldName: /f_[\\w]/, // that is regex that identify the formula fieldName\n};\nexports.ConditionResult = {\n    True: 1,\n    False: 0,\n};\n// Arithmetics operators\nexports.AdditionOperator = \"+\";\nexports.SubtractionOperator = \"-\";\nexports.DivisionOperator = \"/\";\nexports.MultiplicationOperator = \"*\";\nexports.ExponentialOperator = \"^\";\nexports.ModuloOperator = \"%\";\n// Logics operators\nexports.LogicalAndOperator = \"&&\";\nexports.LogicalOrOperator = \"||\";\n// Comparisons operators\nexports.GreaterThanOperator = \">\";\nexports.LessThanOperator = \"<\";\nexports.GreaterThanOrEqualOperator = \">=\";\nexports.LessThanOrEqualOperator = \"<=\";\nexports.EqualOperator = \"==\";\nexports.NotEqualOperator = \"!=\";\n// Others operators\nexports.AssignmentOperator = \"=\";\nexports.ParenthesisOpenOperator = \"(\";\nexports.ParenthesisCloseOperator = \")\";\nexports.ColonOperator = \":\";\nexports.QuestionMarkOperator = \"?\";\nexports.BackslashOperator = \"\\\\\";\nexports.ComparisonOperator = [\n    exports.GreaterThanOperator,\n    exports.LessThanOperator,\n    exports.LogicalOrOperator,\n    exports.LogicalAndOperator,\n    exports.GreaterThanOrEqualOperator,\n    exports.LessThanOrEqualOperator,\n    exports.EqualOperator,\n    exports.NotEqualOperator,\n];\nexports.ArithmeticOperator = [\n    exports.AdditionOperator,\n    exports.SubtractionOperator,\n    exports.DivisionOperator,\n    exports.MultiplicationOperator,\n    exports.ExponentialOperator,\n    exports.ModuloOperator,\n];\nexports.Operators = [\n    ...exports.ArithmeticOperator,\n    ...exports.ComparisonOperator,\n    exports.QuestionMarkOperator,\n];\nexports.AllOperators = [\n    ...exports.Operators,\n    exports.ColonOperator,\n    exports.ParenthesisCloseOperator,\n    exports.ParenthesisOpenOperator,\n];\nexports.Priority_1_Operator = [exports.AdditionOperator, exports.SubtractionOperator];\nexports.Priority_2_Operator = [\n    exports.DivisionOperator,\n    exports.MultiplicationOperator,\n    exports.ModuloOperator,\n];\nexports.Priority_3_Operator = [exports.ExponentialOperator];\nexports.Priority_4_Operator = [\n    ...exports.ComparisonOperator,\n    exports.QuestionMarkOperator,\n];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaInterpreterError = void 0;\nclass FormulaInterpreterError {\n    constructor(message, error) {\n        this.message = message;\n        this.name = \"FormulaInterpreterError\";\n        this.stack = error;\n    }\n}\nexports.FormulaInterpreterError = FormulaInterpreterError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaVariableNotFoundError = void 0;\nclass FormulaVariableNotFoundError extends Error {\n    constructor(message, variableName, variableContainer) {\n        super(message);\n        this.name = \"FormulaVariableNotFound\";\n        this.data = { variableName, container: variableContainer };\n    }\n    getData() {\n        return this.data;\n    }\n}\nexports.FormulaVariableNotFoundError = FormulaVariableNotFoundError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IncorrectSyntaxError = void 0;\nclass IncorrectSyntaxError extends Error {\n    constructor(message, exp) {\n        super(message);\n        this.name = \"IncorrectSyntaxError\";\n        this.data = { exp };\n    }\n    getData() {\n        return this.data;\n    }\n}\nexports.IncorrectSyntaxError = IncorrectSyntaxError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InvalidFormulaError = void 0;\nclass InvalidFormulaError extends Error {\n    constructor(message, exp) {\n        super(message);\n        this.name = \"Invalid formula\";\n        this.data = { exp };\n    }\n    getData() {\n        return this.data;\n    }\n}\nexports.InvalidFormulaError = InvalidFormulaError;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./FormulaInterpreterError\"), exports);\n__exportStar(require(\"./FormulaVariableNotFoundError\"), exports);\n__exportStar(require(\"./IncorrectSyntax\"), exports);\n__exportStar(require(\"./InvalidFormulaError\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BinaryOperation = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a binary operation on two expressions.\n *\n * @template T The input type of the expression.\n * @template R The output type of the expressions.\n * @param {Expression<T, R>} left The left expression.\n * @param {Expression<T, R>} right The right expression.\n * @param {(a: R, b: R) => number} operator The operator function that takes two values of type R and returns a number.\n */\nclass BinaryOperation extends Expression_1.Expression {\n    constructor(left, right, operator) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.operator = operator;\n    }\n    /**\n     * Executes the binary operation on the given object.\n     *\n     * @param {T} obj The object on which the operation will be executed.\n     * @returns {number} The result of the binary operation.\n     */\n    execute(obj) {\n        return this.operator(this.left.execute(obj), this.right.execute(obj));\n    }\n}\nexports.BinaryOperation = BinaryOperation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompiledFormulaExpression = void 0;\nconst FormulaInterpreter_1 = require(\"../interpreter/FormulaInterpreter\");\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\n/**\n * Implementation of the CompiledExpression interface for formula expressions.\n * @class\n * @implements {CompiledExpression}\n */\nclass CompiledFormulaExpression {\n    /**\n     * Creates a new instance of CompiledFormulaExpression.\n     * @param {string} expression - The formula expression to compile\n     */\n    constructor(expression) {\n        this.expression = expression;\n        this.type = \"CompiledExpression\";\n        this._ast = new FormulaParser_1.FormulaParser().execute(new FormulaTokenizer_1.FormulaTokenizer().execute(expression));\n    }\n    /**\n     * Evaluates the expression with the provided data.\n     * @template T\n     * @param {T} data - The data object to evaluate the expression against\n     * @returns {string | number} The result of the evaluation\n     */\n    evaluate(data) {\n        return new FormulaInterpreter_1.FormulaInterpreter().execute(this._ast, data);\n    }\n    /**\n     * Returns the string representation of the expression.\n     * @returns {string} The original expression string\n     */\n    toString() {\n        return this.expression;\n    }\n}\nexports.CompiledFormulaExpression = CompiledFormulaExpression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionalExpression = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a conditional expression that returns values based on a condition.\n *\n * @template T The input type of the expression.\n * @template R The output type of the conditional expression.\n * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.\n * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.\n * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.\n */\nclass ConditionalExpression extends Expression_1.Expression {\n    constructor(condition, isTrue, isFalse) {\n        super();\n        this.condition = condition;\n        this.isTrue = isTrue;\n        this.isFalse = isFalse;\n    }\n    /**\n     * Executes the conditional expression on the given object.\n     *\n     * @param {T} obj The object on which the expression will be evaluated.\n     * @returns {R} The value returned by the conditional expression, based on the evaluation of the condition.\n     */\n    execute(obj) {\n        return this.condition.execute(obj) != 0 ? this.isTrue.execute(obj) : this.isFalse.execute(obj);\n    }\n}\nexports.ConditionalExpression = ConditionalExpression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Expression = void 0;\n/**\n * Represents an abstract expression that defines an interface for evaluating expressions.\n * @template T The input type for the expression.\n * @template R The type of result produced by the expression.\n */\nclass Expression {\n}\nexports.Expression = Expression;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExpressionConstructor = void 0;\nconst LiteralValue_1 = require(\"./LiteralValue\");\nconst FieldReference_1 = require(\"./FieldReference\");\nconst BinaryOperation_1 = require(\"./BinaryOperation\");\nconst ConditionalExpression_1 = require(\"./ConditionalExpression\");\nclass ExpressionConstructor {\n    /**\n     * Creates a literal value expression.\n     *\n     * @template T The input type of the expression.\n     * @template R The output type of the literal value.\n     * @param {R} value The value to be represented as a literal.\n     * @returns {Expression<T, R>} The literal value expression.\n     */\n    static literalValue(value) {\n        return new LiteralValue_1.LiteralValue(value);\n    }\n    /**\n     * Creates a field reference expression based on the provided field name.\n     *\n     * @template T The type of the input object.\n     * @template R The type of the output value from the field.\n     * @param {string} fieldName The name of the field to reference.\n     * @returns {Expression<T, R>} The field reference expression.\n     */\n    static fieldReference(fieldName) {\n        return new FieldReference_1.FieldReference(fieldName);\n    }\n    /**\n     * Creates an addition operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The addition expression.\n     */\n    static addition(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a + b);\n    }\n    /**\n     * Creates a subtraction operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The subtraction expression.\n     */\n    static subtraction(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a - b);\n    }\n    /**\n     * Creates a multiplication operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The multiplication expression.\n     */\n    static multiplication(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a * b);\n    }\n    /**\n     * Creates a division operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The division expression.\n     * @throws {Error} Throws an error if division by zero is attempted.\n     */\n    static division(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => {\n            if (b === 0)\n                throw new Error(\"Division by zero\");\n            return a / b;\n        });\n    }\n    /**\n     * Creates a conditional expression based on the specified condition.\n     *\n     * @template T The input type of the expression.\n     * @template R The output type of the conditional expression.\n     * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.\n     * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.\n     * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.\n     * @returns {Expression<T, R>} The conditional expression.\n     */\n    static condition(condition, isTrue, isFalse) {\n        return new ConditionalExpression_1.ConditionalExpression(condition, isTrue, isFalse);\n    }\n    /**\n     * Creates an equality expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The equality expression.\n     */\n    static equality(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a === b));\n    }\n    /**\n     * Creates a greater-than expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The greater-than expression.\n     */\n    static superior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a > b));\n    }\n    /**\n     * Creates a less-than expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The less-than expression.\n     */\n    static inferior(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a < b));\n    }\n    /**\n     * Creates a not-equal expression comparing two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The not-equal expression.\n     */\n    static different(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a != b));\n    }\n    /**\n     * Creates a logical OR expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The logical OR expression.\n     */\n    static or(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a || b));\n    }\n    /**\n     * Creates a logical AND expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @template R The output type of the expressions.\n     * @param {Expression<T, R>} left The left operand.\n     * @param {Expression<T, R>} right The right operand.\n     * @returns {Expression<T, number>} The logical AND expression.\n     */\n    static and(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Number(a && b));\n    }\n    /**\n     * Creates a power (exponentiation) expression between two expressions.\n     *\n     * @template T The input type of the expressions.\n     * @param {Expression<T, number>} base The base operand.\n     * @param {Expression<T, number>} exponent The exponent operand.\n     * @returns {Expression<T, number>} The result of raising `base` to the power of `right`.\n     */\n    static pow(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => Math.pow(Number(a), Number(b)));\n    }\n    /**\n     * Creates a modulo operation expression between two expressions.\n     *\n     * @template T The type of the input expressions.\n     * @param {Expression<T, number>} left The left operand.\n     * @param {Expression<T, number>} right The right operand.\n     * @returns {Expression<T, number>} The modulo expression.\n     */\n    static modulo(left, right) {\n        return new BinaryOperation_1.BinaryOperation(left, right, (a, b) => a % b);\n    }\n}\nexports.ExpressionConstructor = ExpressionConstructor;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FieldReference = void 0;\nconst Expression_1 = require(\"./Expression\");\nconst constant_1 = require(\"./../constant\");\nconst FormulaParser_1 = require(\"../parser/FormulaParser\");\nconst FormulaTokenizer_1 = require(\"../tokenizer/FormulaTokenizer\");\nconst FormulaInterpreter_1 = require(\"../interpreter/FormulaInterpreter\");\nconst FormulaVariableNotFoundError_1 = require(\"../errors/FormulaVariableNotFoundError\");\n/**\n * Represents a reference to a field in a given object, allowing\n * for the execution of expressions and the interpretation of formulas.\n *\n * @template T - The type of the object containing the fields.\n * @template R - The type of the return value of the expression.\n * @param {string} fieldName - The name of the field to reference in the object.\n */\nclass FieldReference extends Expression_1.Expression {\n    constructor(fieldName) {\n        super();\n        this.fieldName = fieldName;\n    }\n    /**\n     * Executes the field reference on the given object.\n     *\n     * @param {T} obj - The object from which to extract the field value.\n     * @returns {R} The value of the referenced field.\n     * @throws {Error} If the field does not exist or is undefined in the object.\n     */\n    execute(obj) {\n        if (obj != null && obj != undefined) {\n            if (obj[this.fieldName] != undefined) {\n                if (this.isFormulaRef() && typeof obj[this.fieldName] === \"string\")\n                    return this.executeFormulaRef(obj);\n                if (this.isCompiledExpression(obj))\n                    return this.evaluateCompiledExpression(obj);\n                return obj[this.fieldName];\n            }\n        }\n        throw new FormulaVariableNotFoundError_1.FormulaVariableNotFoundError(`The fieldName ${this.fieldName} does not exist or is undefined on object ${obj}`, this.fieldName, obj);\n    }\n    /**\n     * Checks if the field name corresponds to a formula reference.\n     *\n     * @returns {boolean} True if the field is a formula reference, otherwise false.\n     */\n    isFormulaRef() {\n        return constant_1.REGEX.formulaFieldName.test(this.fieldName);\n    }\n    /**\n     * Checks if the field name corresponds to a Compiled Expression\n     * @param obj {T} The object from which to extract the field value.\n     * @returns {boolean}  True if the field is a formula reference, otherwise false.\n     */\n    isCompiledExpression(obj) {\n        var _a;\n        return ((_a = obj[this.fieldName]) === null || _a === void 0 ? void 0 : _a.type) === \"CompiledExpression\";\n    }\n    /**\n     * Executes the formula reference and returns the result of the interpretation.\n     *\n     * @param {T} obj - The object from which to extract the formula.\n     * @returns {R} The result of executing the formula.\n     */\n    executeFormulaRef(obj) {\n        const fTokenizer = new FormulaTokenizer_1.FormulaTokenizer();\n        const fParser = new FormulaParser_1.FormulaParser();\n        const fInterpreter = new FormulaInterpreter_1.FormulaInterpreter();\n        const astTree = fParser.execute(fTokenizer.execute(obj[this.fieldName]));\n        return fInterpreter.execute(astTree, obj);\n    }\n    /**\n     * Evaluate the compiled Expression\n     * @param obj - The object from which to extract the formula.\n     * @returns The result of evaluate the compiled Expression.\n     */\n    evaluateCompiledExpression(obj) {\n        const compiledExpression = obj[this.fieldName];\n        return compiledExpression.evaluate(obj);\n    }\n}\nexports.FieldReference = FieldReference;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiteralValue = void 0;\nconst Expression_1 = require(\"./Expression\");\n/**\n * Represents a literal value expression.\n *\n * @template T The input type of the expression.\n * @template R The output type of the expression, defaulting to number.\n * @param {R} _value The literal value to be returned when executed.\n */\nclass LiteralValue extends Expression_1.Expression {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    /**\n     * Executes the literal value expression and returns the value.\n     *\n     * @param {T} obj The object on which the expression is executed (not used in this case).\n     * @returns {R} The literal value.\n     */\n    execute(obj) {\n        return this._value;\n    }\n}\nexports.LiteralValue = LiteralValue;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidExpression = exports.compile = exports.default = void 0;\nvar api_1 = require(\"./api\");\nObject.defineProperty(exports, \"default\", { enumerable: true, get: function () { return __importDefault(api_1).default; } });\nObject.defineProperty(exports, \"compile\", { enumerable: true, get: function () { return api_1.compile; } });\nObject.defineProperty(exports, \"isValidExpression\", { enumerable: true, get: function () { return api_1.isValidExpression; } });\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./errors\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaInterpreter = void 0;\nconst ExpressionConstructor_1 = require(\"./../expression/ExpressionConstructor\");\nconst constant_1 = require(\"../constant\");\nconst FormulaInterpreterError_1 = require(\"../errors/FormulaInterpreterError\");\n/**\n * The FormulaInterpreter class is responsible for interpreting an abstract syntax tree (AST)\n * representing a mathematical or logical expression. It evaluates expressions based on provided\n * variable data and constructs appropriate expression objects for processing.\n */\nclass FormulaInterpreter {\n    /**\n     * Executes the interpretation of the AST tree and returns the evaluated result.\n     * @param {INode} astTree The abstract syntax tree to be interpreted.\n     * @param {T} data The variable data to use for evaluation.\n     * @returns {number | string} The result of the expression evaluation.\n     */\n    execute(astTree, data) {\n        const result = this.interpret(astTree, data).execute(data);\n        return result;\n    }\n    /**\n     * Interprets the AST tree recursively and constructs expression objects based on the node types.\n     * @param {INode} astTree The abstract syntax tree to interpret.\n     * @param {T} data The variable data to use for evaluation.\n     * @returns {Expression<T, string | number>} The constructed expression object.\n     */\n    interpret(astTree, data) {\n        try {\n            if (astTree.isNode()) {\n                const operator = astTree.operator;\n                const right = this.interpret(astTree.right, data);\n                const left = this.interpret(astTree.left, data);\n                switch (operator) {\n                    case constant_1.AdditionOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.addition(left, right);\n                    case constant_1.SubtractionOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.subtraction(left, right);\n                    case constant_1.MultiplicationOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.multiplication(left, right);\n                    case constant_1.DivisionOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.division(left, right);\n                    case constant_1.ModuloOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.modulo(left, right);\n                    case constant_1.ExponentialOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.pow(left, right);\n                    default:\n                        throw new Error(`This operator ${operator} is not supported.`);\n                }\n            }\n            else if (astTree.isValue()) {\n                const value = astTree.value;\n                if (typeof value === \"number\") {\n                    return ExpressionConstructor_1.ExpressionConstructor.literalValue(Number(astTree.value));\n                }\n                else {\n                    const regex = /[\"']([\\w]+)[\"']/;\n                    const stringValue = value.match(regex)[1];\n                    return ExpressionConstructor_1.ExpressionConstructor.literalValue(stringValue);\n                }\n            }\n            else if (astTree.isField()) {\n                const fieldValue = data[String(astTree.fieldName)];\n                if (fieldValue === undefined)\n                    throw new FormulaInterpreterError_1.FormulaInterpreterError(`The variable ${astTree.fieldName} not defined.`);\n                if (typeof fieldValue === \"number\") {\n                    return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n                }\n                else {\n                    return ExpressionConstructor_1.ExpressionConstructor.fieldReference(astTree.fieldName);\n                }\n            }\n            else if (astTree.isComparison()) {\n                const comparisonOperator = astTree.operator;\n                const left = this.interpret(astTree.left, data);\n                const right = this.interpret(astTree.right, data);\n                switch (comparisonOperator) {\n                    case constant_1.GreaterThanOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.superior(left, right);\n                    case constant_1.LessThanOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.inferior(left, right);\n                    case constant_1.EqualOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.equality(left, right);\n                    case constant_1.GreaterThanOrEqualOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.superior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                    case constant_1.LessThanOrEqualOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.or(ExpressionConstructor_1.ExpressionConstructor.inferior(left, right), ExpressionConstructor_1.ExpressionConstructor.equality(left, right));\n                    case constant_1.LogicalOrOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.or(left, right);\n                    case constant_1.LogicalAndOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.and(left, right);\n                    case constant_1.NotEqualOperator:\n                        return ExpressionConstructor_1.ExpressionConstructor.different(left, right);\n                    default:\n                        throw new FormulaInterpreterError_1.FormulaInterpreterError(`This comparison ${comparisonOperator} method is not supported`);\n                }\n            }\n            else if (astTree.isConditional()) {\n                const condition = this.interpret(astTree.condition, data);\n                const isTrue = this.interpret(astTree.isTrue, data);\n                const isFalse = this.interpret(astTree.isFalse, data);\n                return ExpressionConstructor_1.ExpressionConstructor.condition(condition, isTrue, isFalse);\n            }\n            else {\n                throw new FormulaInterpreterError_1.FormulaInterpreterError(`This Expression is not Correct. Please verify Your expression [Interpreter]:${astTree}`);\n            }\n        }\n        catch (e) {\n            throw e;\n        }\n    }\n}\nexports.FormulaInterpreter = FormulaInterpreter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AstNode = void 0;\nconst constant_1 = require(\"../constant\");\n/**\n * Represents a node in the Abstract Syntax Tree (AST).\n */\nclass AstNode {\n    /**\n     * Determines if this node is conditional.\n     * @returns {boolean} True if the node is conditional; otherwise, false.\n     */\n    isConditional() {\n        return !!this.condition && !!this.isFalse && !!this.isTrue;\n    }\n    /**\n     * Determines if this node represents a value.\n     * @returns {boolean} True if the node is a value; otherwise, false.\n     */\n    isValue() {\n        return this.value != undefined;\n    }\n    /**\n     * Determines if this node is a comparison operator.\n     * @returns {boolean} True if the node is a comparison; otherwise, false.\n     */\n    isComparison() {\n        return !!this.isComparisonOperator();\n    }\n    /**\n     * Determines if this node is a field.\n     * @returns {boolean} True if the node is a field; otherwise, false.\n     */\n    isField() {\n        return !!this.fieldName;\n    }\n    /**\n     * Determines if this node is a generic node.\n     * @returns {boolean} True if the node is a node; otherwise, false.\n     */\n    isNode() {\n        return (!this.isValue() &&\n            !this.isField() &&\n            !this.isComparison() &&\n            !this.isConditional());\n    }\n    /**\n     * Checks if the operator is a comparison operator.\n     * @returns {boolean} True if the operator is a comparison operator; otherwise, false.\n     */\n    isComparisonOperator() {\n        if (constant_1.ComparisonOperator.includes(this.operator))\n            return true;\n        return false;\n    }\n}\nexports.AstNode = AstNode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaParser = void 0;\nconst constant_1 = require(\"../constant\");\nconst errors_1 = require(\"../errors\");\nconst AstNode_1 = require(\"./AstNode\");\n/**\n * Parses formulas and generates an Abstract Syntax Tree (AST).\n */\nclass FormulaParser {\n    /**\n     * Checks if the provided tokens represent a valid formula.\n     * @param tokens - An array of tokens representing the formula.\n     * @returns {boolean} True if the tokens form a valid formula; otherwise, false.\n     */\n    isFormula(tokens) {\n        let notOperatorLastIndex = 1;\n        let operatorLastIndex = 1;\n        const operatorRegex = constant_1.REGEX.formulaOperator;\n        for (let index = 0; index < tokens.length; index++) {\n            const token = tokens[index];\n            const isOperator = operatorRegex.test(String(token));\n            const lastIndex = index - 1;\n            if (isOperator) {\n                operatorLastIndex = index;\n            }\n            else {\n                if (notOperatorLastIndex == lastIndex &&\n                    operatorLastIndex != lastIndex) {\n                    return false;\n                }\n                notOperatorLastIndex = index;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks the syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {IncorrectSyntaxError} Throws an error if the syntax is not correct\n     */\n    checkSyntax(tokens) {\n        this.checkParenthesisSyntax(tokens);\n        this.checkOperatorSyntax(tokens);\n        this.checkTernaryConditionSyntax(tokens);\n    }\n    /**\n     * Checks the parenthesis syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {IncorrectSyntaxError} Throws an error if there is a parenthesis mismatch.\n     */\n    checkParenthesisSyntax(tokens) {\n        const stack = [];\n        tokens.forEach((token) => {\n            if (token === constant_1.ParenthesisOpenOperator)\n                stack.push(constant_1.ParenthesisOpenOperator);\n            if (token === constant_1.ParenthesisCloseOperator) {\n                if (stack.length === 0) {\n                    throw new errors_1.IncorrectSyntaxError(\"Parenthesis mismatch\", tokens.join(\"\"));\n                }\n                stack.pop();\n            }\n        });\n        if (stack.length !== 0) {\n            throw new errors_1.IncorrectSyntaxError(\"Incorrect parenthesis disposition.\", tokens.join(\"\"));\n        }\n    }\n    /**\n     * Checks the operator syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {IncorrectSyntaxError} Throws an error if there is an operator syntax error.\n     */\n    checkOperatorSyntax(tokens) {\n        const regex = /[+-\\/*]{2,}/;\n        /**\n         * @version 1.0.9\n         * @note  Fix issus : Introduction de la copy des tokens avant de faire le join pour le cas ou on aura les valeurs negative\n         */\n        const tokensCopy = tokens.map((token) => typeof token === \"string\" ? token : Math.abs(token));\n        const expression = tokensCopy.join(\"\");\n        if (regex.test(expression)) {\n            throw new errors_1.IncorrectSyntaxError(\"Incorrect Operator error\", expression);\n        }\n        // When tokens length is equal to one and the token is an string or number without operator , just return because is just an operand\n        if (tokens.length == 1 && /\\w/.test(expression))\n            return;\n        const validOperationCheckerRegex = />=|<=|==|!=|&&|\\|\\||[+-\\/*<>%\\^][\\w\\(]/;\n        if (!validOperationCheckerRegex.test(expression)) {\n            throw new errors_1.IncorrectSyntaxError(\"Incorrect Operator position for Operand\", expression);\n        }\n    }\n    /**\n     * Checks the ternary condition syntax of the provided tokens.\n     * @param tokens - An array of tokens to check.\n     * @throws {IncorrectSyntaxError} Throws an error if there is a ternary syntax error.\n     */\n    checkTernaryConditionSyntax(tokens) {\n        let ternaryQuestionMarkCount = 0;\n        let ternaryColonCount = 0;\n        tokens.forEach((token) => {\n            if (token === constant_1.QuestionMarkOperator)\n                ternaryQuestionMarkCount++;\n            if (token === constant_1.ColonOperator)\n                ternaryColonCount++;\n        });\n        if (ternaryQuestionMarkCount !== ternaryColonCount) {\n            throw new errors_1.IncorrectSyntaxError(\"Incorrect Ternary syntax: unmatched ? and :\", tokens.join(\"\"));\n        }\n        const ternaryRegex = /[?:]/;\n        let expectingCondition = true;\n        tokens.forEach((token) => {\n            if (ternaryRegex.test(String(token))) {\n                if (expectingCondition && token === constant_1.ColonOperator) {\n                    throw new errors_1.IncorrectSyntaxError(\"Ternary syntax error: found ':' before '?'\", tokens.join(\"\"));\n                }\n                expectingCondition = !expectingCondition;\n            }\n        });\n    }\n    /**\n     * Check if the provided tokens is valid formula\n     * @param tokens - An array of tokens to verify if is valid formula\n     * @returns {boolean} return true when is valid formula and false if not\n     */\n    isValidFormula(tokens) {\n        try {\n            if (!this.isFormula(tokens))\n                return false;\n            this.checkSyntax(tokens);\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Executes the parsing of the provided tokens and generates an AST.\n     * @param tokens - An array of tokens to parse.\n     * @returns {INode} The root node of the generated AST.\n     * @throws {IncorrectSyntaxError | InvalidFormulaError}  Throws an error if the tokens are not a valid formula.\n     */\n    execute(tokens) {\n        if (tokens.length != 0 && this.isFormula(tokens)) {\n            this.checkSyntax(tokens);\n            return this.parser(tokens);\n        }\n        else {\n            throw new errors_1.InvalidFormulaError(\"Invalid formula error. Please check is formula. \", tokens.join(\"\"));\n        }\n    }\n    /**\n     * Parses the provided tokens and generates an AST.\n     * @param tokens - An array of tokens to parse.\n     * @returns {INode} The root node of the generated AST.\n     */\n    parser(tokens) {\n        const postFixExpression = this.infixToPostFix(tokens);\n        const result = this.generateAST(postFixExpression);\n        return result;\n    }\n    /**\n     * Generates an Abstract Syntax Tree (AST) from the given tokens.\n     * @param tokens - An array of tokens to generate the AST from.\n     * @returns {INode} The root node of the generated AST.\n     */\n    generateAST(tokens) {\n        const stack = [];\n        let counter = 0;\n        return this._generateAST(tokens, counter, stack);\n    }\n    /**\n     * Recursively generates the AST based on the provided tokens and the current index.\n     * @param tokens - An array of tokens to generate the AST from.\n     * @param index - The current index in the tokens array.\n     * @param stack - The stack of nodes being built for the AST.\n     * @returns {INode} The root node of the generated AST.\n     */\n    _generateAST(tokens, index, stack = []) {\n        const token = tokens[index];\n        if (token == undefined)\n            return stack[0];\n        if (this.isOperatorFirstAndParenthesis(token)) {\n            const node = new AstNode_1.AstNode();\n            node.operator = token;\n            if (this.isArithmeticOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isComparisonOperator(token)) {\n                node.right = stack.pop();\n                node.left = stack.pop();\n            }\n            else if (this.isTernaryOperator(token)) {\n                node.isFalse = stack.pop();\n                node.isTrue = stack.pop();\n                node.condition = stack.pop();\n            }\n            stack.push(node);\n        }\n        else {\n            const node = new AstNode_1.AstNode();\n            if (this.isValue(token)) {\n                node.value = token;\n            }\n            else {\n                node.fieldName = token;\n            }\n            stack.push(node);\n        }\n        return this._generateAST(tokens, index + 1, stack);\n    }\n    /**\n     * Converts infix tokens to postfix notation.\n     * @param tokens - An array of tokens in infix notation.\n     * @returns {(string | number)[]} An array of tokens in postfix notation.\n     */\n    infixToPostFix(tokens) {\n        const output = [];\n        const operators = [];\n        tokens.forEach((token) => {\n            if (!this.isOperatorFirstAndParenthesis(token)) {\n                output.push(token);\n            }\n            else {\n                const operatorAndParenthesis = String(token);\n                const priority = this.priority(operatorAndParenthesis);\n                if (operatorAndParenthesis === constant_1.ParenthesisOpenOperator) {\n                    operators.push(operatorAndParenthesis);\n                }\n                else if (operatorAndParenthesis === constant_1.ParenthesisCloseOperator) {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== constant_1.ParenthesisOpenOperator) {\n                        const operator = operators.pop();\n                        if (!(operator.trim() === constant_1.ParenthesisOpenOperator)) {\n                            output.push(operator);\n                        }\n                    }\n                    operators.pop();\n                }\n                else if (operatorAndParenthesis === constant_1.ColonOperator) {\n                    while (operators.length > 0 &&\n                        operators[operators.length - 1] !== constant_1.QuestionMarkOperator) {\n                        output.push(operators.pop());\n                    }\n                }\n                else if (constant_1.Operators.includes(operatorAndParenthesis)) {\n                    while (operators.length > 0 &&\n                        this.priority(operators[operators.length - 1]) >= priority) {\n                        output.push(operators.pop());\n                    }\n                    operators.push(operatorAndParenthesis);\n                }\n                else {\n                }\n            }\n        });\n        while (operators.length > 0) {\n            output.push(operators.pop());\n        }\n        return output;\n    }\n    /**\n     * Determines the priority level of the given operator.\n     *\n     * Operators are assigned the following priority levels:\n     * 1 - Addition and Subtraction\n     * 2 - Multiplication and Division\n     * 3 - Comparison and Logical operators\n     *\n     * @param operator - The operator to evaluate.\n     * @returns {number} The priority level of the operator, where higher numbers indicate higher priority.\n     */\n    priority(operator) {\n        if (constant_1.Priority_1_Operator.includes(operator))\n            return 1;\n        if (constant_1.Priority_2_Operator.includes(operator))\n            return 2;\n        if (constant_1.Priority_3_Operator.includes(operator))\n            return 3;\n        if (constant_1.Priority_4_Operator.includes(operator))\n            return 4;\n        return 0;\n    }\n    /**\n     * Checks if the provided token is an operator or parenthesis.\n     *\n     * This method considers the following tokens as valid operators:\n     * Arithmetic operators: +, -, *, /,^,%\n     * Comparison operators: >, <, >=, <=, ==, !=\n     * Logical operators: ||, &&\n     * Ternary operator: ?\n     * Parentheses: (, )\n     *\n     * @param token - The token to evaluate.\n     * @returns  {boolean} -True if the token is an operator or parenthesis; otherwise, false.\n     */\n    isOperatorFirstAndParenthesis(token) {\n        if (constant_1.AllOperators.includes(String(token).trim()))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is an arithmetic operator.\n     *\n     * The valid arithmetic operators are: +, -, *, /,^,%\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} -True if the token is an arithmetic operator; otherwise, false.\n     */\n    isArithmeticOperator(token) {\n        if (constant_1.ArithmeticOperator.includes(token))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is a comparison operator.\n     *\n     * The valid comparison operators are: >, <, >=, <=, ==, !=, ||, &&\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} -  True if the token is a comparison operator; otherwise, false.\n     */\n    isComparisonOperator(token) {\n        if (constant_1.ComparisonOperator.includes(token))\n            return true;\n        return false;\n    }\n    /**\n     * Checks if the provided token is a ternary operator.\n     *\n     * The valid ternary operator is: ?\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} - True if the token is a ternary operator; otherwise, false.\n     */\n    isTernaryOperator(token) {\n        return constant_1.QuestionMarkOperator === token;\n    }\n    /**\n     * Checks if the provided token is a valid value.\n     *\n     * A valid value can be a number or a string matching the regex pattern for quoted words.\n     *\n     * @param token - The token to evaluate.\n     * @returns {boolean} - True if the token is a valid value; otherwise, false.\n     */\n    isValue(token) {\n        const valueRegex = /[\"'][\\w]+[\"']/;\n        return typeof token === \"number\" || valueRegex.test(token) ? true : false;\n    }\n}\nexports.FormulaParser = FormulaParser;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormulaTokenizer = void 0;\nconst constant_1 = require(\"../constant\");\n/**\n * The FormulaTokenizer class is responsible for tokenizing and formatting\n * mathematical expressions for further evaluation. It handles the input\n * string by formatting it, filtering tokens, and preparing them for processing.\n */\nclass FormulaTokenizer {\n    /**\n     * Formats the input string by replacing operators and trimming whitespace.\n     * @param {string} input The input string to be formatted.\n     * @returns {string} The formatted expression.\n     */\n    formatInput(input) {\n        return input\n            .replace(constant_1.REGEX.formulaOperatorG, \" $1 \")\n            .replace(/\\s+/g, \" \")\n            .trim();\n    }\n    /**\n     * Filters the tokens to handle numbers and operators appropriately.\n     * This method processes the tokens to ensure that numbers and operators\n     * are in the correct format for evaluation.\n     * @param {string[]} tokens The array of tokens to be filtered.\n     * @returns {(string | number)[]} The filtered tokens as an array of strings and numbers.\n     */\n    filterTokens(tokens) {\n        const filteredTokens = [];\n        let expectedClosedParenthesis = false;\n        tokens.forEach((token) => {\n            const regex = /^\\d+(\\.\\d+)?$/;\n            const negativeNumberRegex = /-\\d+/;\n            const lastFilteredToken = filteredTokens[filteredTokens.length - 1];\n            if (regex.test(token)) {\n                const firstPop = filteredTokens.pop();\n                const secondPop = filteredTokens.pop();\n                if (firstPop !== undefined) {\n                    const isSign = constant_1.Priority_1_Operator.includes(firstPop);\n                    const isPrecededByOperator = secondPop !== undefined &&\n                        typeof secondPop === \"string\" &&\n                        constant_1.Operators.includes(secondPop);\n                    const isPrecededByParen = secondPop === constant_1.ParenthesisOpenOperator;\n                    const isAtStart = secondPop === undefined;\n                    if (isSign && isPrecededByParen) {\n                        // Special case for `(-2)`\n                        filteredTokens.push(Number(firstPop + token));\n                        expectedClosedParenthesis = true;\n                    }\n                    else if (isSign && (isPrecededByOperator || isAtStart)) {\n                        // It's a signed number\n                        if (secondPop !== undefined) {\n                            filteredTokens.push(secondPop);\n                        }\n                        filteredTokens.push(Number(firstPop + token));\n                    }\n                    else {\n                        // Not a signed number, push everything back\n                        if (secondPop !== undefined) {\n                            filteredTokens.push(secondPop);\n                        }\n                        filteredTokens.push(firstPop, Number(token));\n                    }\n                }\n                else {\n                    // No token before, just a number\n                    filteredTokens.push(Number(token));\n                }\n            }\n            else if (negativeNumberRegex.test(lastFilteredToken) &&\n                token === constant_1.ParenthesisCloseOperator &&\n                expectedClosedParenthesis) {\n                expectedClosedParenthesis = false;\n            }\n            else {\n                filteredTokens.push(token);\n            }\n        });\n        return filteredTokens;\n    }\n    /**\n     * Executes the tokenization process for the given input string.\n     * This method formats the input, splits it into tokens,\n     * and filters the tokens to produce a final result.\n     * @param {string} input The input string to be tokenized.\n     * @returns {any[]} The array of filtered tokens resulting from the tokenization process.\n     */\n    execute(input) {\n        const formattedInput = this.formatInput(input);\n        if (formattedInput.trim() === \"\")\n            return [];\n        const tokens = formattedInput.split(\" \");\n        const filteredTokens = this.filterTokens(tokens);\n        return filteredTokens;\n    }\n}\nexports.FormulaTokenizer = FormulaTokenizer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constant_1 = require(\"../constant\");\nconst OperatorValue = [...constant_1.ArithmeticOperator, ...constant_1.ComparisonOperator];\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(73);\n"],"names":["root","factory","exports","module","define","amd","this","Object","defineProperty","value","compile","expression","CompiledExpression_1","CompiledFormulaExpression","obj","fTokenizer","FormulaTokenizer_1","FormulaTokenizer","fParser","FormulaParser_1","FormulaParser","FormulaInterpreter_1","FormulaInterpreter","execute","__createBinding","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","__exportStar","p","prototype","hasOwnProperty","call","__importDefault","mod","SmartCal_1","default","isValidExpression","tokens","isValidFormula","_a","Priority_4_Operator","Priority_3_Operator","Priority_2_Operator","Priority_1_Operator","AllOperators","Operators","ArithmeticOperator","ComparisonOperator","BackslashOperator","QuestionMarkOperator","ColonOperator","ParenthesisCloseOperator","ParenthesisOpenOperator","AssignmentOperator","NotEqualOperator","EqualOperator","LessThanOrEqualOperator","GreaterThanOrEqualOperator","LessThanOperator","GreaterThanOperator","LogicalOrOperator","LogicalAndOperator","ModuloOperator","ExponentialOperator","MultiplicationOperator","DivisionOperator","SubtractionOperator","AdditionOperator","ConditionResult","REGEX","formulaOperatorG","formulaOperator","formulaFieldName","True","False","FormulaInterpreterError","constructor","message","error","name","stack","FormulaVariableNotFoundError","Error","variableName","variableContainer","super","data","container","getData","IncorrectSyntaxError","exp","InvalidFormulaError","BinaryOperation","Expression_1","Expression","left","right","operator","type","_ast","evaluate","toString","ConditionalExpression","condition","isTrue","isFalse","ExpressionConstructor","LiteralValue_1","FieldReference_1","BinaryOperation_1","ConditionalExpression_1","literalValue","LiteralValue","fieldReference","fieldName","FieldReference","addition","a","b","subtraction","multiplication","division","equality","Number","superior","inferior","different","or","and","pow","Math","modulo","constant_1","FormulaVariableNotFoundError_1","isFormulaRef","executeFormulaRef","isCompiledExpression","evaluateCompiledExpression","test","fInterpreter","astTree","_value","api_1","ExpressionConstructor_1","FormulaInterpreterError_1","interpret","isNode","isValue","regex","stringValue","match","isField","fieldValue","String","isComparison","isConditional","comparisonOperator","e","AstNode","isComparisonOperator","includes","errors_1","AstNode_1","isFormula","notOperatorLastIndex","operatorLastIndex","operatorRegex","index","length","token","lastIndex","checkSyntax","checkParenthesisSyntax","checkOperatorSyntax","checkTernaryConditionSyntax","forEach","push","join","pop","map","abs","ternaryQuestionMarkCount","ternaryColonCount","ternaryRegex","expectingCondition","parser","postFixExpression","infixToPostFix","generateAST","_generateAST","isOperatorFirstAndParenthesis","node","isArithmeticOperator","isTernaryOperator","output","operators","operatorAndParenthesis","priority","trim","formatInput","input","replace","filterTokens","filteredTokens","expectedClosedParenthesis","lastFilteredToken","firstPop","secondPop","isSign","isPrecededByOperator","isPrecededByParen","isAtStart","formattedInput","split","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}