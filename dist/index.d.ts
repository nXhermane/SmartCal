// Generated by dts-bundle v0.7.3

export { BinaryOperation, ConditionalExpression, Expression, ExpressionConstructor, FieldReference, LiteralValue, FormulaInterpreter, FormulaParser, AstNode, FormulaTokenizer, isValidExpression, ConditionResult, };
export default SmartCal;

/**
    * Represents a binary operation on two expressions.
    *
    * @template T The input type of the expression.
    * @template R The output type of the expressions.
    * @param {Expression<T, R>} left The left expression.
    * @param {Expression<T, R>} right The right expression.
    * @param {(a: R, b: R) => number} operator The operator function that takes two values of type R and returns a number.
    */
export class BinaryOperation<T, R> extends Expression<T, number> {
        constructor(left: Expression<T, R>, right: Expression<T, R>, operator: (a: R, b: R) => number);
        /**
            * Executes the binary operation on the given object.
            *
            * @param {T} obj The object on which the operation will be executed.
            * @returns {number} The result of the binary operation.
            */
        execute(obj: T): number;
}

/**
    * Represents a conditional expression that returns values based on a condition.
    *
    * @template T The input type of the expression.
    * @template R The output type of the conditional expression.
    * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.
    * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.
    * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.
    */
export class ConditionalExpression<T, R> extends Expression<T, R> {
        constructor(condition: Expression<T, number>, isTrue: Expression<T, R>, isFalse: Expression<T, R>);
        /**
            * Executes the conditional expression on the given object.
            *
            * @param {T} obj The object on which the expression will be evaluated.
            * @returns {R} The value returned by the conditional expression, based on the evaluation of the condition.
            */
        execute(obj: T): R;
}

/**
    * Represents an abstract expression that defines an interface for evaluating expressions.
    * @template T The input type for the expression.
    * @template R The type of result produced by the expression.
    */
export abstract class Expression<T, R> {
        /**
            * Evaluates the expression based on the given object.
            * @param {T} obj The object on which the expression will be evaluated.
            * @returns {R} The result of evaluating the expression.
            */
        abstract execute(obj: T): R;
}

export class ExpressionConstructor {
        /**
            * Creates a literal value expression.
            *
            * @template T The input type of the expression.
            * @template R The output type of the literal value.
            * @param {R} value The value to be represented as a literal.
            * @returns {Expression<T, R>} The literal value expression.
            */
        static literalValue<T, R = number>(value: R): Expression<T, R>;
        /**
            * Creates a field reference expression based on the provided field name.
            *
            * @template T The type of the input object.
            * @template R The type of the output value from the field.
            * @param {string} fieldName The name of the field to reference.
            * @returns {Expression<T, R>} The field reference expression.
            */
        static fieldReference<T extends {
                [key: string]: any;
        }, R>(fieldName: string): Expression<T, R>;
        /**
            * Creates an addition operation expression between two expressions.
            *
            * @template T The type of the input expressions.
            * @param {Expression<T, number>} left The left operand.
            * @param {Expression<T, number>} right The right operand.
            * @returns {Expression<T, number>} The addition expression.
            */
        static addition<T>(left: Expression<T, number>, right: Expression<T, number>): Expression<T, number>;
        /**
            * Creates a subtraction operation expression between two expressions.
            *
            * @template T The type of the input expressions.
            * @param {Expression<T, number>} left The left operand.
            * @param {Expression<T, number>} right The right operand.
            * @returns {Expression<T, number>} The subtraction expression.
            */
        static subtraction<T>(left: Expression<T, number>, right: Expression<T, number>): Expression<T, number>;
        /**
            * Creates a multiplication operation expression between two expressions.
            *
            * @template T The type of the input expressions.
            * @param {Expression<T, number>} left The left operand.
            * @param {Expression<T, number>} right The right operand.
            * @returns {Expression<T, number>} The multiplication expression.
            */
        static multiplication<T>(left: Expression<T, number>, right: Expression<T, number>): Expression<T, number>;
        /**
            * Creates a division operation expression between two expressions.
            *
            * @template T The type of the input expressions.
            * @param {Expression<T, number>} left The left operand.
            * @param {Expression<T, number>} right The right operand.
            * @returns {Expression<T, number>} The division expression.
            * @throws {Error} Throws an error if division by zero is attempted.
            */
        static division<T>(left: Expression<T, number>, right: Expression<T, number>): Expression<T, number>;
        /**
            * Creates a conditional expression based on the specified condition.
            *
            * @template T The input type of the expression.
            * @template R The output type of the conditional expression.
            * @param {Expression<T, number>} condition The expression that determines the condition to evaluate.
            * @param {Expression<T, R>} isTrue The expression to execute if the condition is true.
            * @param {Expression<T, R>} isFalse The expression to execute if the condition is false.
            * @returns {Expression<T, R>} The conditional expression.
            */
        static condition<T, R>(condition: Expression<T, number>, isTrue: Expression<T, R>, isFalse: Expression<T, R>): Expression<T, R>;
        /**
            * Creates an equality expression comparing two expressions.
            *
            * @template T The input type of the expressions.
            * @template R The output type of the expressions.
            * @param {Expression<T, R>} left The left operand.
            * @param {Expression<T, R>} right The right operand.
            * @returns {Expression<T, number>} The equality expression.
            */
        static equality<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
        /**
            * Creates a greater-than expression comparing two expressions.
            *
            * @template T The input type of the expressions.
            * @template R The output type of the expressions.
            * @param {Expression<T, R>} left The left operand.
            * @param {Expression<T, R>} right The right operand.
            * @returns {Expression<T, number>} The greater-than expression.
            */
        static superior<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
        /**
            * Creates a less-than expression comparing two expressions.
            *
            * @template T The input type of the expressions.
            * @template R The output type of the expressions.
            * @param {Expression<T, R>} left The left operand.
            * @param {Expression<T, R>} right The right operand.
            * @returns {Expression<T, number>} The less-than expression.
            */
        static inferior<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
        /**
            * Creates a not-equal expression comparing two expressions.
            *
            * @template T The input type of the expressions.
            * @template R The output type of the expressions.
            * @param {Expression<T, R>} left The left operand.
            * @param {Expression<T, R>} right The right operand.
            * @returns {Expression<T, number>} The not-equal expression.
            */
        static different<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
        /**
            * Creates a logical OR expression between two expressions.
            *
            * @template T The input type of the expressions.
            * @template R The output type of the expressions.
            * @param {Expression<T, R>} left The left operand.
            * @param {Expression<T, R>} right The right operand.
            * @returns {Expression<T, number>} The logical OR expression.
            */
        static or<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
        /**
            * Creates a logical AND expression between two expressions.
            *
            * @template T The input type of the expressions.
            * @template R The output type of the expressions.
            * @param {Expression<T, R>} left The left operand.
            * @param {Expression<T, R>} right The right operand.
            * @returns {Expression<T, number>} The logical AND expression.
            */
        static and<T, R>(left: Expression<T, R>, right: Expression<T, R>): Expression<T, number>;
        /**
            * Creates a power (exponentiation) expression between two expressions.
            *
            * @template T The input type of the expressions.
            * @param {Expression<T, number>} base The base operand.
            * @param {Expression<T, number>} exponent The exponent operand.
            * @returns {Expression<T, number>} The result of raising `base` to the power of `right`.
            */
        static pow<T>(left: Expression<T, number>, right: Expression<T, number>): Expression<T, number>;
        /**
            * Creates a modulo operation expression between two expressions.
            *
            * @template T The type of the input expressions.
            * @param {Expression<T, number>} left The left operand.
            * @param {Expression<T, number>} right The right operand.
            * @returns {Expression<T, number>} The modulo expression.
            */
        static modulo<T>(left: Expression<T, number>, right: Expression<T, number>): Expression<T, number>;
}

/**
    * Represents a reference to a field in a given object, allowing
    * for the execution of expressions and the interpretation of formulas.
    *
    * @template T - The type of the object containing the fields.
    * @template R - The type of the return value of the expression.
    * @param {string} fieldName - The name of the field to reference in the object.
    */
export class FieldReference<T extends {
        [kex: string]: any;
}, R> extends Expression<T, R> {
        constructor(fieldName: string);
        /**
            * Executes the field reference on the given object.
            *
            * @param {T} obj - The object from which to extract the field value.
            * @returns {R} The value of the referenced field.
            * @throws {Error} If the field does not exist or is undefined in the object.
            */
        execute(obj: T): R;
}

/**
    * Represents a literal value expression.
    *
    * @template T The input type of the expression.
    * @template R The output type of the expression, defaulting to number.
    * @param {R} _value The literal value to be returned when executed.
    */
export class LiteralValue<T, R = number> extends Expression<T, R> {
        constructor(_value: R);
        /**
            * Executes the literal value expression and returns the value.
            *
            * @param {T} obj The object on which the expression is executed (not used in this case).
            * @returns {R} The literal value.
            */
        execute(obj: T): R;
}

type VariableContainer = {
        [key: string]: string | number;
};
/**
    * The FormulaInterpreter class is responsible for interpreting an abstract syntax tree (AST)
    * representing a mathematical or logical expression. It evaluates expressions based on provided
    * variable data and constructs appropriate expression objects for processing.
    */
export class FormulaInterpreter {
        /**
            * Executes the interpretation of the AST tree and returns the evaluated result.
            * @param {Node} astTree The abstract syntax tree to be interpreted.
            * @param {T} data The variable data to use for evaluation.
            * @returns {number | string} The result of the expression evaluation.
            */
        execute<T extends VariableContainer>(astTree: Node, data: T): number | string;
        /**
            * Interprets the AST tree recursively and constructs expression objects based on the node types.
            * @param {Node} astTree The abstract syntax tree to interpret.
            * @param {T} data The variable data to use for evaluation.
            * @returns {Expression<T, string | number>} The constructed expression object.
            */
        interpret<T extends VariableContainer>(astTree: Node, data: T): Expression<T, string | number>;
}
export {};

const OperatorValue: string[];
/**
    * Represents the supported operators in the expression.
    */
type Operator = typeof OperatorValue[number];
/**
    * Defines the structure of a Node in the Abstract Syntax Tree (AST).
    */
export interface Node {
        operator?: Operator;
        left?: Node;
        right?: Node;
        condition?: Node;
        isTrue?: Node;
        isFalse?: Node;
        value?: number | string;
        fieldName?: string;
        /**
            * Checks if the node is conditional.
            * @returns {boolean} True if the node is conditional; otherwise, false.
            */
        isConditional(): boolean;
        /**
            * Checks if the node represents a value.
            * @returns {boolean} True if the node is a value; otherwise, false.
            */
        isValue(): boolean;
        /**
            * Checks if the node is a comparison operator.
            * @returns {boolean} True if the node is a comparison; otherwise, false.
            */
        isComparison(): boolean;
        /**
            * Checks if the node is a field.
            * @returns {boolean} True if the node is a field; otherwise, false.
            */
        isField(): boolean;
        /**
            * Checks if the node is a generic node.
            * @returns {boolean} True if the node is a node; otherwise, false.
            */
        isNode(): boolean;
}
/**
    * Represents a node in the Abstract Syntax Tree (AST).
    */
export class AstNode implements Node {
        operator?: Operator;
        left?: Node;
        right?: Node;
        condition?: Node;
        isTrue?: Node;
        isFalse?: Node;
        value?: number | string;
        fieldName?: string;
        /**
            * Determines if this node is conditional.
            * @returns {boolean} True if the node is conditional; otherwise, false.
            */
        isConditional(): boolean;
        /**
            * Determines if this node represents a value.
            * @returns {boolean} True if the node is a value; otherwise, false.
            */
        isValue(): boolean;
        /**
            * Determines if this node is a comparison operator.
            * @returns {boolean} True if the node is a comparison; otherwise, false.
            */
        isComparison(): boolean;
        /**
            * Determines if this node is a field.
            * @returns {boolean} True if the node is a field; otherwise, false.
            */
        isField(): boolean;
        /**
            * Determines if this node is a generic node.
            * @returns {boolean} True if the node is a node; otherwise, false.
            */
        isNode(): boolean;
}
/**
    * Parses formulas and generates an Abstract Syntax Tree (AST).
    */
export class FormulaParser {
        /**
            * Check if the provided tokens is valid formula
            * @param tokens - An array of tokens to verify if is valid formula
            * @returns {boolean} return true when is valid formula and false if not
            */
        isValidFormula(tokens: (string | number)[]): boolean;
        /**
            * Executes the parsing of the provided tokens and generates an AST.
            * @param tokens - An array of tokens to parse.
            * @returns {Node} The root node of the generated AST.
            * @throws {Error} Throws an error if the tokens are not a valid formula.
            */
        execute(tokens: (string | number)[]): Node;
}
export {};

/**
    * The FormulaTokenizer class is responsible for tokenizing and formatting
    * mathematical expressions for further evaluation. It handles the input
    * string by formatting it, filtering tokens, and preparing them for processing.
    */
export class FormulaTokenizer {
        /**
            * Formats the input string by replacing operators and trimming whitespace.
            * @param {string} input The input string to be formatted.
            * @returns {string} The formatted expression.
            */
        formatInput(input: string): string;
        /**
            * Filters the tokens to handle numbers and operators appropriately.
            * This method processes the tokens to ensure that numbers and operators
            * are in the correct format for evaluation.
            * @param {string[]} tokens The array of tokens to be filtered.
            * @returns {(string | number)[]} The filtered tokens as an array of strings and numbers.
            */
        filterTokens(tokens: string[]): (string | number)[];
        /**
            * Executes the tokenization process for the given input string.
            * This method formats the input, splits it into tokens,
            * and filters the tokens to produce a final result.
            * @param {string} input The input string to be tokenized.
            * @returns {any[]} The array of filtered tokens resulting from the tokenization process.
            */
        execute(input: string): any[];
}

/**
    * Evaluates a mathematical expression and returns the result.
    *
    * This function parses and interprets a mathematical formula represented as a string,
    * applying dynamic values from a given object to resolve variables or conditions within the expression.
    *
    * @template T - A generic type representing the structure of the input object. Keys are variable names, and values can be numbers, strings, or arrays.
    * @param {string} expression - The mathematical expression to be evaluated.
    *        Variables in the expression should correspond to keys in the `obj` parameter.
    * @param {T} obj - An object containing the values of the variables referenced in the expression.
    * @returns {number | string | any[]} - The result of the evaluated expression, which can be a number, a string, or an array depending on the expression's logic.
    */
export default function SmartCal<T extends {
        [key: string]: number | string;
}>(expression: string, obj: T): number | string;
/**
    * Verify if the given expression is valid formula
    * @param expression expression to evaluate
    * @returns {boolean} true if the expression is valid
    */
export function isValidExpression(expression: string): boolean;

export const REGEX: {
    formulaOperatorG: RegExp;
    formulaOperator: RegExp;
    formulaFieldName: RegExp;
};
export const ConditionResult: {
    True: number;
    False: number;
};
export const AdditionOperator = "+";
export const SubtractionOperator = "-";
export const DivisionOperator = "/";
export const MultiplicationOperator = "*";
export const ExponentialOperator = "^";
export const ModuloOperator = "%";
export const LogicalAndOperator = "&&";
export const LogicalOrOperator = "||";
export const GreaterThanOperator = ">";
export const LessThanOperator = "<";
export const GreaterThanOrEqualOperator = ">=";
export const LessThanOrEqualOperator = "<=";
export const EqualOperator = "==";
export const NotEqualOperator = "!=";
export const AssignmentOperator = "=";
export const ParenthesisOpenOperator = "(";
export const ParenthesisCloseOperator = ")";
export const ColonOperator = ":";
export const QuestionMarkOperator = "?";
export const BackslashOperator = "\\";
export const ComparisonOperator: string[];
export const ArithmeticOperator: string[];
export const Operators: string[];
export const AllOperators: string[];
export const Priority_1_Operator: string[];
export const Priority_2_Operator: string[];
export const Priority_3_Operator: string[];
export const Priority_4_Operator: string[];

